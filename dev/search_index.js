var documenterSearchIndex = {"docs":
[{"location":"style/#Julia-Coding-Style-Guide-for-SIIP","page":"Julia Coding Style Guide for SIIP","title":"Julia Coding Style Guide for SIIP","text":"","category":"section"},{"location":"style/#Goals","page":"Julia Coding Style Guide for SIIP","title":"Goals","text":"","category":"section"},{"location":"style/","page":"Julia Coding Style Guide for SIIP","title":"Julia Coding Style Guide for SIIP","text":"Define a straightforward set of rules that lead to consistent, readable","category":"page"},{"location":"style/","page":"Julia Coding Style Guide for SIIP","title":"Julia Coding Style Guide for SIIP","text":"code.","category":"page"},{"location":"style/","page":"Julia Coding Style Guide for SIIP","title":"Julia Coding Style Guide for SIIP","text":"Developers focus on producing high quality code, not how to format it.","category":"page"},{"location":"style/#Base","page":"Julia Coding Style Guide for SIIP","title":"Base","text":"","category":"section"},{"location":"style/","page":"Julia Coding Style Guide for SIIP","title":"Julia Coding Style Guide for SIIP","text":"Follow the official","category":"page"},{"location":"style/","page":"Julia Coding Style Guide for SIIP","title":"Julia Coding Style Guide for SIIP","text":"Julia style guide except for deviations noted here.","category":"page"},{"location":"style/","page":"Julia Coding Style Guide for SIIP","title":"Julia Coding Style Guide for SIIP","text":"Follow Julia contribution guidelines, notably its line length","category":"page"},{"location":"style/","page":"Julia Coding Style Guide for SIIP","title":"Julia Coding Style Guide for SIIP","text":"limit.","category":"page"},{"location":"style/","page":"Julia Coding Style Guide for SIIP","title":"Julia Coding Style Guide for SIIP","text":"Follow Julia guidelines for docstrings.\nFollow JuMP coding standards,","category":"page"},{"location":"style/","page":"Julia Coding Style Guide for SIIP","title":"Julia Coding Style Guide for SIIP","text":"including its deviations from the Julia style guide.  In particular, note its policies on","category":"page"},{"location":"style/","page":"Julia Coding Style Guide for SIIP","title":"Julia Coding Style Guide for SIIP","text":"whitespace\nreturn statements\nvariable names.\nRead The Zen of Python.\nConsider using a plugin that configures your text editor to use EditorConfig settings.","category":"page"},{"location":"style/#Code-Organization","page":"Julia Coding Style Guide for SIIP","title":"Code Organization","text":"","category":"section"},{"location":"style/","page":"Julia Coding Style Guide for SIIP","title":"Julia Coding Style Guide for SIIP","text":"Import standard modules, then 3rd-party modules, then yours. Include a blank","category":"page"},{"location":"style/","page":"Julia Coding Style Guide for SIIP","title":"Julia Coding Style Guide for SIIP","text":"line between each group.","category":"page"},{"location":"style/#Modules:-TODO","page":"Julia Coding Style Guide for SIIP","title":"Modules:  TODO","text":"","category":"section"},{"location":"style/#Comments","page":"Julia Coding Style Guide for SIIP","title":"Comments","text":"","category":"section"},{"location":"style/","page":"Julia Coding Style Guide for SIIP","title":"Julia Coding Style Guide for SIIP","text":"Use comments to describe non-obvious or non-trivial aspects of code.","category":"page"},{"location":"style/","page":"Julia Coding Style Guide for SIIP","title":"Julia Coding Style Guide for SIIP","text":"Describe why something was done but not how.  The \"how\" should be apparent from the code itself.","category":"page"},{"location":"style/","page":"Julia Coding Style Guide for SIIP","title":"Julia Coding Style Guide for SIIP","text":"Use complete sentences and proper grammar.\nInclude a space in between the \"#\" and the first word of the comment.\nUse these tags in comments to describe known work:\nTODO:  tasks that need to be done\nFIXME:  code that needs refactoring\nBUG:  known bug that exists. Should include a bug ID and tracking system.\nPERF:  known performance limitation that needs improvement","category":"page"},{"location":"style/#Constructors","page":"Julia Coding Style Guide for SIIP","title":"Constructors","text":"","category":"section"},{"location":"style/","page":"Julia Coding Style Guide for SIIP","title":"Julia Coding Style Guide for SIIP","text":"Per guidance from Julia documentation, use inner constructors to enforce","category":"page"},{"location":"style/","page":"Julia Coding Style Guide for SIIP","title":"Julia Coding Style Guide for SIIP","text":"restrictions on parameters or to allow construction of self-referential objects. Use outer constructors to provide default values or to perform customization.","category":"page"},{"location":"style/","page":"Julia Coding Style Guide for SIIP","title":"Julia Coding Style Guide for SIIP","text":"Document the reason why the outer constructor is different.\nNote that the compiler will provide a default constructor with all struct","category":"page"},{"location":"style/","page":"Julia Coding Style Guide for SIIP","title":"Julia Coding Style Guide for SIIP","text":"members if no inner constructor is defined.","category":"page"},{"location":"style/","page":"Julia Coding Style Guide for SIIP","title":"Julia Coding Style Guide for SIIP","text":"When creating a constructor use \"function Foo()\" instead of \"Foo() = ...\"","category":"page"},{"location":"style/","page":"Julia Coding Style Guide for SIIP","title":"Julia Coding Style Guide for SIIP","text":"One exception is the case where one file has all single-line functions.","category":"page"},{"location":"style/#Exceptions","page":"Julia Coding Style Guide for SIIP","title":"Exceptions","text":"","category":"section"},{"location":"style/","page":"Julia Coding Style Guide for SIIP","title":"Julia Coding Style Guide for SIIP","text":"Use exceptions for unexpected errors and not for normal error handling.\nDetection of an unsupported data format from a user should likely throw","category":"page"},{"location":"style/","page":"Julia Coding Style Guide for SIIP","title":"Julia Coding Style Guide for SIIP","text":"an exception and terminate the application.","category":"page"},{"location":"style/","page":"Julia Coding Style Guide for SIIP","title":"Julia Coding Style Guide for SIIP","text":"Do not use try/catch to handle retrieving a potentially-missing key from a","category":"page"},{"location":"style/","page":"Julia Coding Style Guide for SIIP","title":"Julia Coding Style Guide for SIIP","text":"dictionary.","category":"page"},{"location":"style/","page":"Julia Coding Style Guide for SIIP","title":"Julia Coding Style Guide for SIIP","text":"Use @assert statements to guard against programming errors. Do not use them","category":"page"},{"location":"style/","page":"Julia Coding Style Guide for SIIP","title":"Julia Coding Style Guide for SIIP","text":"after detecting bad user input. Note that they may be compiled out in release builds.","category":"page"},{"location":"style/#Globals","page":"Julia Coding Style Guide for SIIP","title":"Globals","text":"","category":"section"},{"location":"style/","page":"Julia Coding Style Guide for SIIP","title":"Julia Coding Style Guide for SIIP","text":"Global constants should use UPPER_CASE and be declared const.\nIf global variables are needed, prefix them with \"g_\".\nDon't use magic numbers. Instead, define const globals or Enums (Julia","category":"page"},{"location":"style/","page":"Julia Coding Style Guide for SIIP","title":"Julia Coding Style Guide for SIIP","text":"@enum).","category":"page"},{"location":"style/#One-line-Conditionals","page":"Julia Coding Style Guide for SIIP","title":"One-line Conditionals","text":"","category":"section"},{"location":"style/","page":"Julia Coding Style Guide for SIIP","title":"Julia Coding Style Guide for SIIP","text":"Julia code base uses this idiom frequently:  <cond> && <statement> Example:","category":"page"},{"location":"style/","page":"Julia Coding Style Guide for SIIP","title":"Julia Coding Style Guide for SIIP","text":"","category":"page"},{"location":"style/","page":"Julia Coding Style Guide for SIIP","title":"Julia Coding Style Guide for SIIP","text":"function fact(n::Int)\n   n >= 0 || error(\"n must be non-negative\")\n   n == 0 && return 1\n   n * fact(n-1)\nend","category":"page"},{"location":"style/","page":"Julia Coding Style Guide for SIIP","title":"Julia Coding Style Guide for SIIP","text":"This is acceptable for simple code as in this example. However, in general, prefer to write out an entire if statement.","category":"page"},{"location":"style/","page":"Julia Coding Style Guide for SIIP","title":"Julia Coding Style Guide for SIIP","text":"Ternary operators provide a way to write clean, concise code.  Use good judgement.","category":"page"},{"location":"style/","page":"Julia Coding Style Guide for SIIP","title":"Julia Coding Style Guide for SIIP","text":"Good:","category":"page"},{"location":"style/","page":"Julia Coding Style Guide for SIIP","title":"Julia Coding Style Guide for SIIP","text":"","category":"page"},{"location":"style/","page":"Julia Coding Style Guide for SIIP","title":"Julia Coding Style Guide for SIIP","text":"y = x > 0 ? x : -x","category":"page"},{"location":"style/","page":"Julia Coding Style Guide for SIIP","title":"Julia Coding Style Guide for SIIP","text":"There are many examples in our codebase that use the form <cond> ? <statement> : <statement>.  These can be expressed much more clearly in an if/else statement.","category":"page"},{"location":"style/#Unit-Tests","page":"Julia Coding Style Guide for SIIP","title":"Unit Tests","text":"","category":"section"},{"location":"style/","page":"Julia Coding Style Guide for SIIP","title":"Julia Coding Style Guide for SIIP","text":"All code should be tested.","category":"page"},{"location":"style/#Whitespace","page":"Julia Coding Style Guide for SIIP","title":"Whitespace","text":"","category":"section"},{"location":"style/","page":"Julia Coding Style Guide for SIIP","title":"Julia Coding Style Guide for SIIP","text":"If many function arguments cause the line length to be exceeded, put one","category":"page"},{"location":"style/","page":"Julia Coding Style Guide for SIIP","title":"Julia Coding Style Guide for SIIP","text":"argument per line. In some cases it may make sense to pair some variables on the same line.","category":"page"},{"location":"style/","page":"Julia Coding Style Guide for SIIP","title":"Julia Coding Style Guide for SIIP","text":"","category":"page"},{"location":"style/","page":"Julia Coding Style Guide for SIIP","title":"Julia Coding Style Guide for SIIP","text":"function foo(var1::String,\n             var2::String,\n             var3::String,\n             var4::String,\n             var5::String,\n             var6::String)","category":"page"},{"location":"style/","page":"Julia Coding Style Guide for SIIP","title":"Julia Coding Style Guide for SIIP","text":"Do not surround equal signs with spaces when passing keyword args to a","category":"page"},{"location":"style/","page":"Julia Coding Style Guide for SIIP","title":"Julia Coding Style Guide for SIIP","text":"function or defining default values in function declarations.","category":"page"},{"location":"style/","page":"Julia Coding Style Guide for SIIP","title":"Julia Coding Style Guide for SIIP","text":"Do not right-align equal signs when assigning groups of variables. It causes","category":"page"},{"location":"style/","page":"Julia Coding Style Guide for SIIP","title":"Julia Coding Style Guide for SIIP","text":"unnecessary changes whenever someone adds a new variable with a longer name.","category":"page"},{"location":"style/","page":"Julia Coding Style Guide for SIIP","title":"Julia Coding Style Guide for SIIP","text":"Bad:","category":"page"},{"location":"style/","page":"Julia Coding Style Guide for SIIP","title":"Julia Coding Style Guide for SIIP","text":"","category":"page"},{"location":"style/","page":"Julia Coding Style Guide for SIIP","title":"Julia Coding Style Guide for SIIP","text":"x   = 1\nfoo = 2","category":"page"},{"location":"style/","page":"Julia Coding Style Guide for SIIP","title":"Julia Coding Style Guide for SIIP","text":"Good:","category":"page"},{"location":"style/","page":"Julia Coding Style Guide for SIIP","title":"Julia Coding Style Guide for SIIP","text":"","category":"page"},{"location":"style/","page":"Julia Coding Style Guide for SIIP","title":"Julia Coding Style Guide for SIIP","text":"x = 1\nfoo = 2","category":"page"},{"location":"style/","page":"Julia Coding Style Guide for SIIP","title":"Julia Coding Style Guide for SIIP","text":"Define abstract types on one line. Given the lack of IDE support for Julia,","category":"page"},{"location":"style/","page":"Julia Coding Style Guide for SIIP","title":"Julia Coding Style Guide for SIIP","text":"this makes it easier to find type definitions.","category":"page"},{"location":"style/","page":"Julia Coding Style Guide for SIIP","title":"Julia Coding Style Guide for SIIP","text":"Bad:","category":"page"},{"location":"style/","page":"Julia Coding Style Guide for SIIP","title":"Julia Coding Style Guide for SIIP","text":"","category":"page"},{"location":"style/","page":"Julia Coding Style Guide for SIIP","title":"Julia Coding Style Guide for SIIP","text":"abstract type\n    Foo\nend","category":"page"},{"location":"style/","page":"Julia Coding Style Guide for SIIP","title":"Julia Coding Style Guide for SIIP","text":"Good:","category":"page"},{"location":"style/","page":"Julia Coding Style Guide for SIIP","title":"Julia Coding Style Guide for SIIP","text":"","category":"page"},{"location":"style/","page":"Julia Coding Style Guide for SIIP","title":"Julia Coding Style Guide for SIIP","text":"abstract type Foo end","category":"page"},{"location":"user_guide/installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"user_guide/installation/","page":"Installation","title":"Installation","text":"The latest stable release of PowerSystems can be installed using the Julia package manager with","category":"page"},{"location":"user_guide/installation/","page":"Installation","title":"Installation","text":"] add InfrastructureSystems","category":"page"},{"location":"user_guide/installation/","page":"Installation","title":"Installation","text":"For the current development version, \"checkout\" this package with","category":"page"},{"location":"user_guide/installation/","page":"Installation","title":"Installation","text":"] add InfrastructureSystems#master","category":"page"},{"location":"user_guide/installation/#Getting-test-data-to-start-with-some-data","page":"Installation","title":"Getting test data to start with some data","text":"","category":"section"},{"location":"user_guide/logging/#Logging","page":"Logging","title":"Logging","text":"","category":"section"},{"location":"user_guide/logging/","page":"Logging","title":"Logging","text":"This document describes logging facilities available in the modules that use InfrastructureSystems. The examples assume the following imports:","category":"page"},{"location":"user_guide/logging/","page":"Logging","title":"Logging","text":"import Logging\nimport InfrastructureSystems: configure_logging, open_file_logger, MultiLogger, LogEventTracker","category":"page"},{"location":"user_guide/logging/#Use-Cases","page":"Logging","title":"Use Cases","text":"","category":"section"},{"location":"user_guide/logging/#Enable-logging-in-REPL-or-Jupyter-Notebook","page":"Logging","title":"Enable logging in REPL or Jupyter Notebook","text":"","category":"section"},{"location":"user_guide/logging/","page":"Logging","title":"Logging","text":"Use configure_logging to create a logger with your preferences (console and/or file, levels, etc.).","category":"page"},{"location":"user_guide/logging/","page":"Logging","title":"Logging","text":"Note: log messages are not automatically flushed to files. Call flush(logger) to make this happen.","category":"page"},{"location":"user_guide/logging/","page":"Logging","title":"Logging","text":"Example: Global logger configuration","category":"page"},{"location":"user_guide/logging/","page":"Logging","title":"Logging","text":"logger = configure_logging(; filename=\"log.txt\")\n@info \"hello world\"\nflush(logger)\n@error \"some error\"\nclose(logger)","category":"page"},{"location":"user_guide/logging/","page":"Logging","title":"Logging","text":"The function provides lots of customization. Refer to the docstring for complete details.","category":"page"},{"location":"user_guide/logging/#Log-to-console-and-file-in-an-application-or-unit-test-environment.","page":"Logging","title":"Log to console and file in an application or unit test environment.","text":"","category":"section"},{"location":"user_guide/logging/","page":"Logging","title":"Logging","text":"Create a MultiLogger from Logging.ConsoleLogger and Logging.SimpleLogger. Use open_file_logger to guarantee that all messages get flushed to the file.","category":"page"},{"location":"user_guide/logging/","page":"Logging","title":"Logging","text":"Example Multilogger configuration","category":"page"},{"location":"user_guide/logging/","page":"Logging","title":"Logging","text":"console_logger = ConsoleLogger(stderr, Logging.Error)\n\nopen_file_logger(\"log.txt\", Logging.Info) do file_logger\n    multi_logger = MultiLogger([console_logger, file_logger])\n    global_logger(multi_logger)\n\n    do_stuff()\nend","category":"page"},{"location":"user_guide/logging/","page":"Logging","title":"Logging","text":"Note: If someone may execute the code in the REPL then wrap that code in a try/finally block and reset the global logger upon exit.","category":"page"},{"location":"user_guide/logging/","page":"Logging","title":"Logging","text":"function run_tests()\n    console_logger = ConsoleLogger(stderr, Logging.Error)\n\n    open_file_logger(\"log.txt\", Logging.Info) do file_logger\n        multi_logger = MultiLogger([console_logger, file_logger])\n        global_logger(multi_logger)\n\n        do_stuff()\n    end\nend\n\nlogger = global_logger()\n\ntry\n    run_tests()\nfinally\n    # Guarantee that the global logger is reset.\n    global_logger(logger)\n    nothing\nend","category":"page"},{"location":"user_guide/logging/#Suppress-frequent-messages","page":"Logging","title":"Suppress frequent messages","text":"","category":"section"},{"location":"user_guide/logging/","page":"Logging","title":"Logging","text":"The standard Logging module in Julia provides a method to suppress messages. Tag the log message with maxlog=X.","category":"page"},{"location":"user_guide/logging/","page":"Logging","title":"Logging","text":"for i in range(1, length=100)\n    @error \"something happened\" i maxlog=2\nend","category":"page"},{"location":"user_guide/logging/","page":"Logging","title":"Logging","text":"Only 2 messages will get logged.","category":"page"},{"location":"user_guide/logging/#Get-a-summary-of-log-messages","page":"Logging","title":"Get a summary of log messages","text":"","category":"section"},{"location":"user_guide/logging/","page":"Logging","title":"Logging","text":"By default a MultiLogger creates a LogEventTracker that keeps counts of all messages. Call report_log_summary after execution.","category":"page"},{"location":"user_guide/logging/","page":"Logging","title":"Logging","text":"logger = configure_logging(; filename=\"log.txt\")\n@info \"hello world\"\n\n# Include a summary in the log file.\n@info report_log_summary(logger)\nclose(logger)","category":"page"},{"location":"user_guide/logging/","page":"Logging","title":"Logging","text":"julia> for i in range(1, length=100)\n           @info \"hello\" maxlog=2\n           @warn \"beware\" maxlog=2\n       end\njulia> @info report_log_summary(logger)\n┌ Info:\n│ Log message summary:\n│\n│ 0 Error events:\n│\n│ 1 Warn events:\n│   count=100 at REPL[19]:3\n│     example message=\"beware\"\n│     suppressed=98\n│\n│ 1 Info events:\n│   count=100 at REPL[19]:2\n│     example message=\"hello\"\n└     suppressed=98","category":"page"},{"location":"api/InfrastructureSystems/#InfrastructureSystems","page":"API","title":"InfrastructureSystems","text":"","category":"section"},{"location":"api/InfrastructureSystems/","page":"API","title":"API","text":"Modules = [InfrastructureSystems]\nOrder = [:type, :function]","category":"page"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.DataFormatError","page":"API","title":"InfrastructureSystems.DataFormatError","text":"Thrown upon detection of user data that is not supported.\n\n\n\n\n\n","category":"type"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.Deterministic","page":"API","title":"InfrastructureSystems.Deterministic","text":"mutable struct Deterministic <: Forecast\n    label::String\n    data::TimeSeries.TimeArray\nend\n\nA deterministic forecast for a particular data field in a Component.\n\nArguments\n\nlabel::String: label of component parameter forecasted\ndata::TimeSeries.TimeArray: timestamp - scalingfactor\n\n\n\n\n\n","category":"type"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.Deterministic-Tuple{String,Dates.Period,Dates.DateTime,Int64}","page":"API","title":"InfrastructureSystems.Deterministic","text":"Deterministic(label::String, resolution::Dates.Period, initial_time::Dates.DateTime, time_steps::Int64) -> InfrastructureSystems.Deterministic\n\n\nConstructs Deterministic after constructing a TimeArray from initialtime and timesteps.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.DeterministicInternal","page":"API","title":"InfrastructureSystems.DeterministicInternal","text":"mutable struct DeterministicInternal <: ForecastInternal\n    label::String\n    resolution::Dates.Period\n    initial_time::Dates.DateTime\n    time_series_uuid::UUIDs.UUID\n    horizon::Int\n    internal::InfrastructureSystemsInternal\nend\n\nA deterministic forecast for a particular data field in a Component.\n\nArguments\n\nlabel::String: label of component parameter forecasted\nresolution::Dates.Period\ninitial_time::Dates.DateTime: forecast availability time\ntime_series_uuid::UUIDs.UUID: reference to time series data; timestamp - scalingfactor\nhorizon::Int: length of this forecast\ninternal::InfrastructureSystemsInternal\n\n\n\n\n\n","category":"type"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.DeviceParameter","page":"API","title":"InfrastructureSystems.DeviceParameter","text":"Base type for auxillary structs. These should not be stored in a system.\n\n\n\n\n\n","category":"type"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.FileLogger","page":"API","title":"InfrastructureSystems.FileLogger","text":"Specializes the behavior of SimpleLogger by adding timestamps and process and thread IDs.\n\n\n\n\n\n","category":"type"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.FlattenIteratorWrapper","page":"API","title":"InfrastructureSystems.FlattenIteratorWrapper","text":"Wrapper around Iterators.Flatten to provide total length.\n\n\n\n\n\n","category":"type"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.Forecast","page":"API","title":"InfrastructureSystems.Forecast","text":"Abstract type for forecasts supplied to users. They are not stored in a system. Instead, they are generated on demand for the user. Users can create them. The system will convert them to a subtype of ForecastInternal for storage. Time series data is stored as a field, so reads will always be from memory.\n\n\n\n\n\n","category":"type"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.ForecastInternal","page":"API","title":"InfrastructureSystems.ForecastInternal","text":"Abstract type for forecasts that are stored in a system. Users never create them or get access to them. Stores references to time series data, so a disk read may be required for access.\n\n\n\n\n\n","category":"type"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.ForecastMetadata","page":"API","title":"InfrastructureSystems.ForecastMetadata","text":"Container for forecasts and their metadata..\n\n\n\n\n\n","category":"type"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.Forecasts","page":"API","title":"InfrastructureSystems.Forecasts","text":"Forecast container for a component.\n\n\n\n\n\n","category":"type"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.Hdf5TimeSeriesStorage","page":"API","title":"InfrastructureSystems.Hdf5TimeSeriesStorage","text":"Stores all time series data in an HDF5 file.\n\nThe file used is assumed to be temporary and will be automatically deleted when there are no more references to the storage object.\n\n\n\n\n\n","category":"type"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.Hdf5TimeSeriesStorage-Tuple{Bool}","page":"API","title":"InfrastructureSystems.Hdf5TimeSeriesStorage","text":"Hdf5TimeSeriesStorage(create_file::Bool; filename, directory, read_only) -> InfrastructureSystems.Hdf5TimeSeriesStorage\n\n\nConstructs Hdf5TimeSeriesStorage.\n\nArguments\n\ncreate_file::Bool: create new file\nfilename=nothing: if nothing, create a temp file, else use this name.\ndirectory=nothing: if set and filename is nothing, create a temp file in this  directory. Use tempdir() if not set. This should be set if the time series data is larger  than the tmp filesystem can hold.\nread_only = false: If true, don't allow changes to the file. Allows simultaneous read  access.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.Hdf5TimeSeriesStorage-Tuple{}","page":"API","title":"InfrastructureSystems.Hdf5TimeSeriesStorage","text":"Hdf5TimeSeriesStorage() -> InfrastructureSystems.Hdf5TimeSeriesStorage\n\n\nConstructs Hdf5TimeSeriesStorage by creating a temp file.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.InMemoryTimeSeriesStorage","page":"API","title":"InfrastructureSystems.InMemoryTimeSeriesStorage","text":"Stores all time series data in memory.\n\n\n\n\n\n","category":"type"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.InMemoryTimeSeriesStorage-Tuple{InfrastructureSystems.Hdf5TimeSeriesStorage}","page":"API","title":"InfrastructureSystems.InMemoryTimeSeriesStorage","text":"InMemoryTimeSeriesStorage(hdf5_storage::InfrastructureSystems.Hdf5TimeSeriesStorage) -> InfrastructureSystems.InMemoryTimeSeriesStorage\n\n\nConstructs InMemoryTimeSeriesStorage from an instance of Hdf5TimeSeriesStorage.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.InfrastructureSystemsComponent","page":"API","title":"InfrastructureSystems.InfrastructureSystemsComponent","text":"Base type for structs that are stored in a system.\n\nRequired interface functions for subtypes:\n\nget_name()\nget_internal()\n\nOptional interface functions:\n\nget_forecasts()\n\nSubtypes may contain forecasts.\n\n\n\n\n\n","category":"type"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.InfrastructureSystemsInternal","page":"API","title":"InfrastructureSystems.InfrastructureSystemsInternal","text":"Internal storage common to InfrastructureSystems types.\n\n\n\n\n\n","category":"type"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.InfrastructureSystemsInternal-Tuple{Base.UUID}","page":"API","title":"InfrastructureSystems.InfrastructureSystemsInternal","text":"InfrastructureSystemsInternal(u::Base.UUID) -> InfrastructureSystems.InfrastructureSystemsInternal\n\n\nCreates PowerSystemInternal with an existing UUID.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.InfrastructureSystemsInternal-Tuple{}","page":"API","title":"InfrastructureSystems.InfrastructureSystemsInternal","text":"InfrastructureSystemsInternal(; uuid, units_info, ext) -> InfrastructureSystems.InfrastructureSystemsInternal\n\n\nCreates PowerSystemInternal with a new UUID.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.InfrastructureSystemsType","page":"API","title":"InfrastructureSystems.InfrastructureSystemsType","text":"Base type for any struct in the SIIP packages. All structs must implement a kwarg-only constructor to allow deserializing from a Dict.\n\n\n\n\n\n","category":"type"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.LazyDictFromIterator-Union{Tuple{V}, Tuple{K}, Tuple{Type{K},Type{V},Any,Function}} where V where K","page":"API","title":"InfrastructureSystems.LazyDictFromIterator","text":"LazyDictFromIterator creates a dictionary from an iterator, but only increments the iterator and adds items to the dictionary as it needs them. In the worst case it is identical to creating a dictionary by iterating over the entire list. Each V should have a K member.\n\nArguments\n\nK: type of the dictionary keys\nV: type of the dictionary values\niter: any object implementing the Iterator interface\ngetter::Function: method to call on V to get its K\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.LogEvent","page":"API","title":"InfrastructureSystems.LogEvent","text":"Contains information describing a log event.\n\n\n\n\n\n","category":"type"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.LogEventTracker","page":"API","title":"InfrastructureSystems.LogEventTracker","text":"LogEventTracker() -> InfrastructureSystems.LogEventTracker\nLogEventTracker(levels::Any) -> InfrastructureSystems.LogEventTracker\n\n\nTracks counts of all log events by level.\n\nExamples\n\nLogEventTracker()\nLogEventTracker((Logging.Info, Logging.Warn, Logging.Error))\n\n\n\n\n\n","category":"type"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.MultiLogger","page":"API","title":"InfrastructureSystems.MultiLogger","text":"Redirects log events to multiple loggers. The primary use case is to allow logging to both a file and the console. Secondarily, it can track the counts of all log messages.\n\nExample\n\nMultiLogger([ConsoleLogger(stderr), SimpleLogger(stream)], LogEventTracker())\n\n\n\n\n\n","category":"type"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.MultiLogger-Union{Tuple{Array{T,N} where N}, Tuple{T}} where T<:Base.CoreLogging.AbstractLogger","page":"API","title":"InfrastructureSystems.MultiLogger","text":"MultiLogger(loggers::Array{T<:Base.CoreLogging.AbstractLogger,N} where N) -> InfrastructureSystems.MultiLogger\n\n\nCreates a MultiLogger with no event tracking.\n\nExample\n\nMultiLogger([ConsoleLogger(stderr), SimpleLogger(stream)])\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.PiecewiseFunction","page":"API","title":"InfrastructureSystems.PiecewiseFunction","text":"mutable struct PiecewiseFunction <: Forecast\n    label::String\n    break_points::Int\n    data::TimeSeries.TimeArray\nend\n\nA forecast for  piecewise function data field in a Component.\n\nArguments\n\nlabel::String: label of component parameter forecasted\nbreak_points::Int: Number of break points\ndata::TimeSeries.TimeArray: timestamp - scalingfactor\n\n\n\n\n\n","category":"type"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.PiecewiseFunction-Tuple{String,Dates.Period,Dates.DateTime,Int64,Int64}","page":"API","title":"InfrastructureSystems.PiecewiseFunction","text":"PiecewiseFunction(label::String, resolution::Dates.Period, initial_time::Dates.DateTime, break_points::Int64, time_steps::Int64) -> InfrastructureSystems.PiecewiseFunction\n\n\nConstructs PiecewiseFunction Forecast after constructing a TimeArray from initialtime and timesteps.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.PiecewiseFunctionInternal","page":"API","title":"InfrastructureSystems.PiecewiseFunctionInternal","text":"mutable struct PiecewiseFunctionInternal <: ForecastInternal\n    label::String\n    resolution::Dates.Period\n    initial_time::Dates.DateTime\n    break_points::Int\n    time_series_uuid::UUIDs.UUID\n    horizon::Int\n    internal::InfrastructureSystemsInternal\nend\n\nA forecast for piecewise function data field in a Component.\n\nArguments\n\nlabel::String: label of component parameter forecasted\nresolution::Dates.Period\ninitial_time::Dates.DateTime: forecast availability time\nbreak_points::Int: Number of break points\ntime_series_uuid::UUIDs.UUID: reference to time series data; timestamp - scalingfactor\nhorizon::Int: length of this forecast\ninternal::InfrastructureSystemsInternal\n\n\n\n\n\n","category":"type"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.Probabilistic","page":"API","title":"InfrastructureSystems.Probabilistic","text":"mutable struct Probabilistic <: Forecast\n    label::String\n    percentiles::Vector{Float64}\n    data::TimeSeries.TimeArray\nend\n\nA Probabilistic forecast for a particular data field in a Component.\n\nArguments\n\nlabel::String: label of component parameter forecasted\npercentiles::Vector{Float64}: Percentiles for the probabilistic forecast\ndata::TimeSeries.TimeArray: timestamp - scalingfactor\n\n\n\n\n\n","category":"type"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.Probabilistic-Tuple{String,Dates.Period,Dates.DateTime,Array{Float64,1},Int64}","page":"API","title":"InfrastructureSystems.Probabilistic","text":"Probabilistic(label::String, resolution::Dates.Period, initial_time::Dates.DateTime, percentiles::Array{Float64,1}, time_steps::Int64) -> InfrastructureSystems.Probabilistic\n\n\nConstructs Probabilistic after constructing a TimeArray from initialtime and timesteps.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.ProbabilisticInternal","page":"API","title":"InfrastructureSystems.ProbabilisticInternal","text":"mutable struct ProbabilisticInternal <: ForecastInternal\n    label::String\n    resolution::Dates.Period\n    initial_time::Dates.DateTime\n    percentiles::Vector{Float64}\n    time_series_uuid::UUIDs.UUID\n    horizon::Int\n    internal::InfrastructureSystemsInternal\nend\n\nA Probabilistic forecast for a particular data field in a Component.\n\nArguments\n\nlabel::String: label of component parameter forecasted\nresolution::Dates.Period\ninitial_time::Dates.DateTime: forecast availability time\npercentiles::Vector{Float64}: Percentiles for the probabilistic forecast\ntime_series_uuid::UUIDs.UUID: reference to time series data; timestamp - scalingfactor\nhorizon::Int: length of this forecast\ninternal::InfrastructureSystemsInternal\n\n\n\n\n\n","category":"type"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.Recorder","page":"API","title":"InfrastructureSystems.Recorder","text":"Records user-defined events in JSON format.\n\n\n\n\n\n","category":"type"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.Recorder-Tuple{Symbol}","page":"API","title":"InfrastructureSystems.Recorder","text":"Recorder(name::Symbol; io, mode, directory) -> InfrastructureSystems.Recorder\n\n\nConstruct a Recorder.\n\nArguments\n\nname::Symbol: name of recorder\nio::Union{Nothing, IO}:  If nothing, record events in a file using name.\nmode = \"w\":  Only used when io is nothing.\ndirectory = \".\":  Only used when io is nothing.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.Results","page":"API","title":"InfrastructureSystems.Results","text":"To implement a sub-type of this you need to implement the methods below.\n\n\n\n\n\n","category":"type"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.ScenarioBased","page":"API","title":"InfrastructureSystems.ScenarioBased","text":"mutable struct ScenarioBased <: Forecast\n    label::String\n    scenario_count::Int64\n    data::TimeSeries.TimeArray\nend\n\nA Discrete Scenario Based forecast for a particular data field in a Component.\n\nArguments\n\nlabel::String: label of component parameter forecasted\nscenario_count::Int64: Number of scenarios\ndata::TimeSeries.TimeArray: timestamp - scalingfactor\n\n\n\n\n\n","category":"type"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.ScenarioBased-Tuple{String,Dates.Period,Dates.DateTime,Int64,Int64}","page":"API","title":"InfrastructureSystems.ScenarioBased","text":"ScenarioBased(label::String, resolution::Dates.Period, initial_time::Dates.DateTime, scenario_count::Int64, time_steps::Int64) -> InfrastructureSystems.ScenarioBased\n\n\nConstructs ScenarioBased Forecast after constructing a TimeArray from initialtime and timesteps.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.ScenarioBasedInternal","page":"API","title":"InfrastructureSystems.ScenarioBasedInternal","text":"mutable struct ScenarioBasedInternal <: ForecastInternal\n    label::String\n    resolution::Dates.Period\n    initial_time::Dates.DateTime\n    scenario_count::Int64\n    time_series_uuid::UUIDs.UUID\n    horizon::Int\n    internal::InfrastructureSystemsInternal\nend\n\nA Discrete Scenario Based forecast for a particular data field in a Component.\n\nArguments\n\nlabel::String: label of component parameter forecasted\nresolution::Dates.Period\ninitial_time::Dates.DateTime: forecast availability time\nscenario_count::Int64: Number of scenarios\ntime_series_uuid::UUIDs.UUID: reference to time series data; timestamp - scalingfactor\nhorizon::Int: length of this forecast\ninternal::InfrastructureSystemsInternal\n\n\n\n\n\n","category":"type"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.SystemData","page":"API","title":"InfrastructureSystems.SystemData","text":"mutable struct SystemData <: InfrastructureSystemsType\n    components::Components\n    forecast_metadata::ForecastMetadata\n    validation_descriptors::Vector\n    time_series_storage::TimeSeriesStorage\n    time_series_storage_file::Union{Nothing, String}\n    internal::InfrastructureSystemsInternal\nend\n\nContainer for system components and time series data\n\n\n\n\n\n","category":"type"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.SystemData-Tuple{}","page":"API","title":"InfrastructureSystems.SystemData","text":"SystemData(; validation_descriptor_file, time_series_in_memory, time_series_directory) -> InfrastructureSystems.SystemData\n\n\nConstruct SystemData to store components and time series data.\n\nArguments\n\nvalidation_descriptor_file = nothing: Optionally, a file defining component validation descriptors.\ntime_series_in_memory = false: Controls whether time series data is stored in memory or in a file.\ntimeseriesdirectory = nothing`: Controls what directory time series data is stored in. Default is tempdir().\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.TimeSeriesStorage","page":"API","title":"InfrastructureSystems.TimeSeriesStorage","text":"Abstract type for time series storage implementations.\n\nAll subtypes must implement:\n\naddtimeseries!\naddtimeseries_reference!\nremovetimeseries!\ngettimeseries\ncleartimeseries!\ngetnumtime_series\ncheckreadonly\n\n\n\n\n\n","category":"type"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.TimeseriesFileMetadata","page":"API","title":"InfrastructureSystems.TimeseriesFileMetadata","text":"Describes how to construct forecasts from raw timeseries data files.\n\n\n\n\n\n","category":"type"},{"location":"api/InfrastructureSystems/#Base.close-Tuple{InfrastructureSystems.MultiLogger}","page":"API","title":"Base.close","text":"close(logger::InfrastructureSystems.MultiLogger)\n\n\nEnsures that any file streams are flushed and closed.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#Base.flush-Tuple{InfrastructureSystems.MultiLogger}","page":"API","title":"Base.flush","text":"flush(logger::InfrastructureSystems.MultiLogger)\n\n\nFlush any file streams.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#Base.get-Union{Tuple{K}, Tuple{InfrastructureSystems.LazyDictFromIterator,K}} where K","page":"API","title":"Base.get","text":"get(container::InfrastructureSystems.LazyDictFromIterator, key::K) -> Any\n\n\nReturns the item mapped to key. If the key is already stored then it will be returned with a dictionary lookup. If it has not been stored then iterate over the list until it is found.\n\nReturns nothing if key is not found.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems._get_all_concrete_subtypes-Union{Tuple{T}, Tuple{Type{T},Array{DataType,1}}} where T","page":"API","title":"InfrastructureSystems._get_all_concrete_subtypes","text":"_get_all_concrete_subtypes(_::Type{T}, sub_types::Array{DataType,1})\n\n\nRecursively builds a vector of subtypes.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems._remove_item!-Tuple{HDF5.HDF5Group,AbstractString,AbstractString}","page":"API","title":"InfrastructureSystems._remove_item!","text":"_remove_item!(path::HDF5.HDF5Group, name::AbstractString, value::AbstractString) -> Bool\n\n\nRemoves value from the dataset called name. Returns true if the array is empty afterwards.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems._split_forecast-Union{Tuple{T}, Tuple{T,TimeSeries.TimeArray}} where T<:InfrastructureSystems.Forecast","page":"API","title":"InfrastructureSystems._split_forecast","text":"_split_forecast(forecast::T<:InfrastructureSystems.Forecast, data::TimeSeries.TimeArray) -> Any\n\n\nCreates a new forecast from an existing forecast with a split TimeArray.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems._validate_component-Union{Tuple{T}, Tuple{InfrastructureSystems.SystemData,T}} where T<:InfrastructureSystems.InfrastructureSystemsComponent","page":"API","title":"InfrastructureSystems._validate_component","text":"_validate_component(data::InfrastructureSystems.SystemData, component::T<:InfrastructureSystems.InfrastructureSystemsComponent)\n\n\nChecks that the component exists in data and the UUID's match.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.add_component!-Union{Tuple{T}, Tuple{InfrastructureSystems.Components,T}} where T<:InfrastructureSystems.InfrastructureSystemsComponent","page":"API","title":"InfrastructureSystems.add_component!","text":"Add a component.\n\nThrows ArgumentError if the component's name is already stored for its concrete type.\n\nThrows InvalidRange if any of the component's field values are outside of defined valid range.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.add_forecast!","page":"API","title":"InfrastructureSystems.add_forecast!","text":"add_forecast!(data::InfrastructureSystems.SystemData, df::DataFrames.DataFrame, component::InfrastructureSystems.InfrastructureSystemsComponent, label::AbstractString) -> Union{Nothing, Set{Tuple{Base.UUID,String}}, InfrastructureSystems._TimeSeriesRecord}\nadd_forecast!(data::InfrastructureSystems.SystemData, df::DataFrames.DataFrame, component::InfrastructureSystems.InfrastructureSystemsComponent, label::AbstractString, scaling_factor::Union{Float64, String}; timestamp) -> Union{Nothing, Set{Tuple{Base.UUID,String}}, InfrastructureSystems._TimeSeriesRecord}\n\n\nAdd a forecast to a system from a DataFrames.DataFrame.\n\nSee TimeseriesFileMetadata for description of scaling_factor.\n\n\n\n\n\n","category":"function"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.add_forecast!-2","page":"API","title":"InfrastructureSystems.add_forecast!","text":"add_forecast!(data::InfrastructureSystems.SystemData, filename::AbstractString, component::InfrastructureSystems.InfrastructureSystemsComponent, label::AbstractString) -> Union{Nothing, Set{Tuple{Base.UUID,String}}, InfrastructureSystems._TimeSeriesRecord}\nadd_forecast!(data::InfrastructureSystems.SystemData, filename::AbstractString, component::InfrastructureSystems.InfrastructureSystemsComponent, label::AbstractString, scaling_factor::Union{Float64, String}) -> Union{Nothing, Set{Tuple{Base.UUID,String}}, InfrastructureSystems._TimeSeriesRecord}\n\n\nAdd a forecast from a CSV file.\n\nSee TimeseriesFileMetadata for description of scaling_factor.\n\n\n\n\n\n","category":"function"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.add_forecast!-3","page":"API","title":"InfrastructureSystems.add_forecast!","text":"add_forecast!(data::InfrastructureSystems.SystemData, ta::TimeSeries.TimeArray, component::InfrastructureSystems.InfrastructureSystemsComponent, label::AbstractString) -> Union{Nothing, Set{Tuple{Base.UUID,String}}, InfrastructureSystems._TimeSeriesRecord}\nadd_forecast!(data::InfrastructureSystems.SystemData, ta::TimeSeries.TimeArray, component::InfrastructureSystems.InfrastructureSystemsComponent, label::AbstractString, scaling_factor::Union{Float64, String}) -> Union{Nothing, Set{Tuple{Base.UUID,String}}, InfrastructureSystems._TimeSeriesRecord}\n\n\nAdd a forecast to a system from a TimeSeries.TimeArray.\n\nSee TimeseriesFileMetadata for description of scaling_factor.\n\n\n\n\n\n","category":"function"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.add_forecast!-Tuple{InfrastructureSystems.SystemData,InfrastructureSystems.InfrastructureSystemsComponent,InfrastructureSystems.Forecast}","page":"API","title":"InfrastructureSystems.add_forecast!","text":"add_forecast!(data::InfrastructureSystems.SystemData, component::InfrastructureSystems.InfrastructureSystemsComponent, forecast::InfrastructureSystems.Forecast) -> Any\n\n\nAdd a forecast.\n\nArguments\n\ndata::SystemData: infrastructure\nforecast: Any object of subtype forecast\n\nThrows ArgumentError if the forecast's component is not stored in the system.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.add_forecasts!-Union{Tuple{T}, Tuple{Type{T},InfrastructureSystems.SystemData,AbstractString}} where T<:InfrastructureSystems.InfrastructureSystemsComponent","page":"API","title":"InfrastructureSystems.add_forecasts!","text":"add_forecasts!(::Type{T<:InfrastructureSystems.InfrastructureSystemsComponent}, data::InfrastructureSystems.SystemData, metadata_file::AbstractString; resolution)\n\n\nAdds forecasts from a metadata file or metadata descriptors.\n\nArguments\n\n::Type{T}: forecasted component type; may be abstract\ndata::SystemData: system\nmetadata_file::AbstractString: metadata file for timeseries that includes an array of TimeseriesFileMetadata instances or a vector.\nresolution::DateTime.Period=nothing: skip forecast that don't match this resolution.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.add_forecasts!-Union{Tuple{T}, Tuple{Type{T},InfrastructureSystems.SystemData,Array{InfrastructureSystems.TimeseriesFileMetadata,1}}} where T<:InfrastructureSystems.InfrastructureSystemsComponent","page":"API","title":"InfrastructureSystems.add_forecasts!","text":"add_forecasts!(::Type{T<:InfrastructureSystems.InfrastructureSystemsComponent}, data::InfrastructureSystems.SystemData, timeseries_metadata::Array{InfrastructureSystems.TimeseriesFileMetadata,1}; resolution)\n\n\nAdds forecasts from a metadata file or metadata descriptors.\n\nArguments\n\ndata::SystemData: system\ntimeseries_metadata::Vector{TimeseriesFileMetadata}: metadata for timeseries\nresolution::DateTime.Period=nothing: skip forecast that don't match this resolution.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.are_forecasts_contiguous-Tuple{InfrastructureSystems.InfrastructureSystemsComponent}","page":"API","title":"InfrastructureSystems.are_forecasts_contiguous","text":"are_forecasts_contiguous(component::InfrastructureSystems.InfrastructureSystemsComponent) -> Bool\n\n\nReturn true if the forecasts are contiguous.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.are_forecasts_contiguous-Tuple{InfrastructureSystems.SystemData}","page":"API","title":"InfrastructureSystems.are_forecasts_contiguous","text":"are_forecasts_contiguous(data::InfrastructureSystems.SystemData) -> Bool\n\n\nReturn true if forecasts are stored contiguously.\n\nThrows ArgumentError if there are no forecasts stored.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.assign_new_uuid!-Tuple{InfrastructureSystems.InfrastructureSystemsType}","page":"API","title":"InfrastructureSystems.assign_new_uuid!","text":"assign_new_uuid!(obj::InfrastructureSystems.InfrastructureSystemsType) -> Base.UUID\n\n\nAssign a new UUID.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.check_contiguous_forecasts-Tuple{InfrastructureSystems.InfrastructureSystemsComponent,Any,Dates.Period,Int64}","page":"API","title":"InfrastructureSystems.check_contiguous_forecasts","text":"check_contiguous_forecasts(component::InfrastructureSystems.InfrastructureSystemsComponent, existing_initial_times::Any, resolution::Dates.Period, horizon::Int64) -> Tuple{Any,Any}\n\n\nThrows ArgumentError if the forecasts are not in consecutive order.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.check_forecast_consistency-Tuple{InfrastructureSystems.Components}","page":"API","title":"InfrastructureSystems.check_forecast_consistency","text":"check_forecast_consistency(components::InfrastructureSystems.Components)\n\n\nThrows DataFormatError if forecasts have inconsistent parameters.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.clear_components!-Tuple{InfrastructureSystems.Components}","page":"API","title":"InfrastructureSystems.clear_components!","text":"clear_components!(components::InfrastructureSystems.Components)\n\n\nRemoves all components from the system.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.clear_ext!-Tuple{InfrastructureSystems.InfrastructureSystemsInternal}","page":"API","title":"InfrastructureSystems.clear_ext!","text":"clear_ext!(obj::InfrastructureSystems.InfrastructureSystemsInternal)\n\n\nClear any value stored in ext.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.compare_values-Union{Tuple{T}, Tuple{T,T}} where T","page":"API","title":"InfrastructureSystems.compare_values","text":"compare_values(x::T, y::T) -> Bool\n\n\nRecursively compares struct values by performing == on each field in the struct. When performing == on values of immutable structs Julia will perform === on each field.  This will return false if any field is mutable even if the contents are the same.  So, comparison of any InfrastructureSystems type with an array will fail.\n\nThis is an unresolved Julia issue. Refer to https://github.com/JuliaLang/julia/issues/4648.\n\nAn option is to overload == for all subtypes of PowerSystemType. That may not be appropriate in all cases. Until the Julia developers decide on a solution, this function is provided for convenience for specific comparisons.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.configure_logging-Tuple{}","page":"API","title":"InfrastructureSystems.configure_logging","text":"configure_logging(; console, console_stream, console_level, file, filename, file_level, file_mode, tracker, set_global) -> InfrastructureSystems.MultiLogger\n\n\nCreates console and file loggers per caller specification and returns a MultiLogger.\n\nNote: If logging to a file users must call Base.close() on the returned MultiLogger to ensure that all events get flushed.\n\nArguments\n\nconsole::Bool=true: create console logger\nconsole_stream::IOStream=stderr: stream for console logger\nconsole_level::Logging.LogLevel=Logging.Error: level for console messages\nfile::Bool=true: create file logger\nfilename::String=log.txt: log file\nfile_level::Logging.LogLevel=Logging.Info: level for file messages\nfile_mode::String=w+: mode used when opening log file\ntracker::Union{LogEventTracker, Nothing}=LogEventTracker(): optionally track log events\nset_global::Bool=true: set the created logger as the global logger\n\nExample\n\nlogger = configure_logging(filename=\"mylog.txt\")\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.copy_forecasts!","page":"API","title":"InfrastructureSystems.copy_forecasts!","text":"copy_forecasts!(dst::InfrastructureSystems.InfrastructureSystemsComponent, src::InfrastructureSystems.InfrastructureSystemsComponent)\ncopy_forecasts!(dst::InfrastructureSystems.InfrastructureSystemsComponent, src::InfrastructureSystems.InfrastructureSystemsComponent, label_mapping::Union{Nothing, Dict{String,String}})\n\n\nEfficiently add all forecasts in one component to another by copying the underlying references.\n\nArguments\n\ndst::InfrastructureSystemsComponent: Destination component\nsrc::InfrastructureSystemsComponent: Source component\nlabel_mapping::Dict = nothing: Optionally map src labels to different dst labels. If provided and src has a forecast with a label not present in labelmapping, that forecast will not copied. If labelmapping is nothing then all forecasts will be copied with src's labels.\n\n\n\n\n\n","category":"function"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.deserialize-Union{Tuple{T}, Tuple{Type{T},Dict}} where T<:InfrastructureSystems.InfrastructureSystemsType","page":"API","title":"InfrastructureSystems.deserialize","text":"deserialize(_::Type{T<:InfrastructureSystems.InfrastructureSystemsType}, data::Dict) -> InfrastructureSystems.TestComponent\n\n\nDeserialize an object from standard types stored in non-Julia formats, such as JSON, into Julia types.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.deserialize_parametric_type-Union{Tuple{T}, Tuple{Type{T},Module,Dict}} where T<:InfrastructureSystems.InfrastructureSystemsType","page":"API","title":"InfrastructureSystems.deserialize_parametric_type","text":"deserialize_parametric_type(_::Type{T<:InfrastructureSystems.InfrastructureSystemsType}, mod::Module, data::Dict) -> Any\n\n\nDeserialize a parametric type. The default implementation strips the parametric types and calls the constructor with only the base type.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.from-Union{Tuple{T}, Tuple{T,Any}} where T<:InfrastructureSystems.Forecast","page":"API","title":"InfrastructureSystems.from","text":"from(forecast::T<:InfrastructureSystems.Forecast, timestamp::Any) -> Union{InfrastructureSystems.Deterministic, InfrastructureSystems.PiecewiseFunction, InfrastructureSystems.ScenarioBased}\n\n\nReturn a forecast truncated starting with timestamp.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.from_file-Tuple{Type{InfrastructureSystems.Hdf5TimeSeriesStorage},AbstractString}","page":"API","title":"InfrastructureSystems.from_file","text":"from_file(::Type{InfrastructureSystems.Hdf5TimeSeriesStorage}, filename::AbstractString; read_only) -> InfrastructureSystems.Hdf5TimeSeriesStorage\n\n\nConstructs Hdf5TimeSeriesStorage from an existing file.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.from_json-Union{Tuple{T}, Tuple{Type{T},String}} where T<:InfrastructureSystems.InfrastructureSystemsType","page":"API","title":"InfrastructureSystems.from_json","text":"from_json(_::Type{T<:InfrastructureSystems.InfrastructureSystemsType}, filename::String) -> Any\n\n\nDeserializes a InfrastructureSystemsType from a JSON filename.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.from_json-Union{Tuple{T}, Tuple{Union{IO, String},Type{T}}} where T<:InfrastructureSystems.InfrastructureSystemsType","page":"API","title":"InfrastructureSystems.from_json","text":"from_json(io::Union{IO, String}, _::Type{T<:InfrastructureSystems.InfrastructureSystemsType}) -> InfrastructureSystems.TestComponent\n\n\nDeserializes a InfrastructureSystemsType from String or IO.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.generate_initial_times-Tuple{InfrastructureSystems.InfrastructureSystemsComponent,Dates.Period,Int64}","page":"API","title":"InfrastructureSystems.generate_initial_times","text":"generate_initial_times(component::InfrastructureSystems.InfrastructureSystemsComponent, interval::Dates.Period, horizon::Int64; initial_time) -> Array{Dates.DateTime,1}\n\n\nGenerates all possible initial times for the stored forecasts. This should return the same result regardless of whether the forecasts have been stored as one contiguous array or chunks of contiguous arrays, such as one 365-day forecast vs 365 one-day forecasts.\n\nThrows ArgumentError if there are no forecasts stored, interval is not a multiple of the system's forecast resolution, or if the stored forecasts have overlapping timestamps.\n\nArguments\n\ncomponent::InfrastructureSystemsComponent: Component containing forecasts.\ninterval::Dates.Period: Amount of time in between each initial time.\nhorizon::Int: Length of each forecast array.\ninitial_time::Union{Nothing, Dates.DateTime}=nothing: Start with this time. If nothing, use the first initial time.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.generate_initial_times-Tuple{InfrastructureSystems.SystemData,Dates.Period,Int64}","page":"API","title":"InfrastructureSystems.generate_initial_times","text":"generate_initial_times(data::InfrastructureSystems.SystemData, interval::Dates.Period, horizon::Int64; initial_time) -> Array{Dates.DateTime,1}\n\n\nGenerates all possible initial times for the stored forecasts. This should return the same result regardless of whether the forecasts have been stored as one contiguous array or chunks of contiguous arrays, such as one 365-day forecast vs 365 one-day forecasts.\n\nThrows ArgumentError if there are no forecasts stored, interval is not a multiple of the system's forecast resolution, or if the stored forecasts have overlapping timestamps.\n\nArguments\n\ndata::SystemData: system\ninterval::Dates.Period: Amount of time in between each initial time.\nhorizon::Int: Length of each forecast array.\ninitial_time::Union{Nothing, Dates.DateTime}=nothing: Start with this time. If nothing, use the first initial time.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.get_abstract_subtypes-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"API","title":"InfrastructureSystems.get_abstract_subtypes","text":"Returns an array of abstract types that are direct subtypes of T.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.get_all_concrete_subtypes-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"API","title":"InfrastructureSystems.get_all_concrete_subtypes","text":"Returns an array of all concrete subtypes of T. Note that this does not find parameterized types.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.get_break_points-Tuple{InfrastructureSystems.PiecewiseFunctionInternal}","page":"API","title":"InfrastructureSystems.get_break_points","text":"get_break_points(value::InfrastructureSystems.PiecewiseFunctionInternal) -> Int64\n\n\nGet PiecewiseFunctionInternal break_points.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.get_break_points-Tuple{InfrastructureSystems.PiecewiseFunction}","page":"API","title":"InfrastructureSystems.get_break_points","text":"get_break_points(value::InfrastructureSystems.PiecewiseFunction) -> Int64\n\n\nGet PiecewiseFunction break_points.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.get_component-Union{Tuple{T}, Tuple{Type{T},InfrastructureSystems.Components,AbstractString}} where T<:InfrastructureSystems.InfrastructureSystemsComponent","page":"API","title":"InfrastructureSystems.get_component","text":"Get the component of type T with name. Returns nothing if no component matches. If T is an abstract type then the names of components across all subtypes of T must be unique.\n\nSee get_components_by_name for abstract types with non-unique names across subtypes.\n\nThrows ArgumentError if T is not a concrete type and there is more than one component with     requested name\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.get_components-Union{Tuple{T}, Tuple{Type{T},InfrastructureSystems.Components}, Tuple{Type{T},InfrastructureSystems.Components,Union{Nothing, Function}}} where T<:InfrastructureSystems.InfrastructureSystemsComponent","page":"API","title":"InfrastructureSystems.get_components","text":"get_components(::Type{T<:InfrastructureSystems.InfrastructureSystemsComponent}, components::InfrastructureSystems.Components) -> InfrastructureSystems.FlattenIteratorWrapper{T<:InfrastructureSystems.InfrastructureSystemsComponent}\nget_components(::Type{T<:InfrastructureSystems.InfrastructureSystemsComponent}, components::InfrastructureSystems.Components, filter_func::Union{Nothing, Function}) -> InfrastructureSystems.FlattenIteratorWrapper{T<:InfrastructureSystems.InfrastructureSystemsComponent}\n\n\nReturns an iterator of components. T can be concrete or abstract. Call collect on the result if an array is desired.\n\nArguments\n\nT: component type\ncomponents::Components: Components of the sytem\nfilter_func::Union{Nothing, Function} = nothing: Optional function that accepts a component  of type T and returns a Bool. Apply this function to each component and only return components  where the result is true.\n\nSee also: iterate_components\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.get_components_by_name-Union{Tuple{T}, Tuple{Type{T},InfrastructureSystems.Components,AbstractString}} where T<:InfrastructureSystems.InfrastructureSystemsComponent","page":"API","title":"InfrastructureSystems.get_components_by_name","text":"Get the components of abstract type T with name. Note that InfrastructureSystems enforces unique names on each concrete type but not across concrete types.\n\nSee get_component if the concrete type is known.\n\nThrows ArgumentError if T is not an abstract type.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.get_concrete_subtypes-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"API","title":"InfrastructureSystems.get_concrete_subtypes","text":"Returns an array of concrete types that are direct subtypes of T.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.get_data-Tuple{InfrastructureSystems.Deterministic}","page":"API","title":"InfrastructureSystems.get_data","text":"get_data(value::InfrastructureSystems.Deterministic) -> TimeSeries.TimeArray\n\n\nGet Deterministic data.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.get_data-Tuple{InfrastructureSystems.PiecewiseFunction}","page":"API","title":"InfrastructureSystems.get_data","text":"get_data(value::InfrastructureSystems.PiecewiseFunction) -> TimeSeries.TimeArray\n\n\nGet PiecewiseFunction data.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.get_data-Tuple{InfrastructureSystems.Probabilistic}","page":"API","title":"InfrastructureSystems.get_data","text":"get_data(value::InfrastructureSystems.Probabilistic) -> TimeSeries.TimeArray\n\n\nGet Probabilistic data.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.get_data-Tuple{InfrastructureSystems.ScenarioBased}","page":"API","title":"InfrastructureSystems.get_data","text":"get_data(value::InfrastructureSystems.ScenarioBased) -> TimeSeries.TimeArray\n\n\nGet ScenarioBased data.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.get_ext-Tuple{InfrastructureSystems.InfrastructureSystemsInternal}","page":"API","title":"InfrastructureSystems.get_ext","text":"get_ext(obj::InfrastructureSystems.InfrastructureSystemsInternal) -> Union{Nothing, Dict{String,Any}}\n\n\nReturn a user-modifiable dictionary to store extra information.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.get_forecast-Union{Tuple{T}, Tuple{Type{T},InfrastructureSystems.InfrastructureSystemsComponent,Dates.DateTime,AbstractString,Int64}} where T<:InfrastructureSystems.Forecast","page":"API","title":"InfrastructureSystems.get_forecast","text":"get_forecast(_::Type{T<:InfrastructureSystems.Forecast}, component::InfrastructureSystems.InfrastructureSystemsComponent, initial_time::Dates.DateTime, label::AbstractString, horizon::Int64) -> Any\n\n\nReturn a forecast for a subset of the time series range stored for these parameters. The range may span time series arrays as long as those timestamps are contiguous.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.get_forecast-Union{Tuple{T}, Tuple{Type{T},InfrastructureSystems.InfrastructureSystemsComponent,Dates.DateTime,AbstractString}} where T<:InfrastructureSystems.Forecast","page":"API","title":"InfrastructureSystems.get_forecast","text":"get_forecast(_::Type{T<:InfrastructureSystems.Forecast}, component::InfrastructureSystems.InfrastructureSystemsComponent, initial_time::Dates.DateTime, label::AbstractString) -> Any\n\n\nReturn a forecast for the entire time series range stored for these parameters.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.get_forecast_counts-Tuple{InfrastructureSystems.SystemData}","page":"API","title":"InfrastructureSystems.get_forecast_counts","text":"get_forecast_counts(data::InfrastructureSystems.SystemData) -> Tuple{Int64,Int64}\n\n\nReturn a tuple of counts of components with forecasts and total forecasts.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.get_forecast_values-Union{Tuple{T}, Tuple{Type{T},Module,InfrastructureSystems.InfrastructureSystemsComponent,Dates.DateTime,AbstractString}} where T<:InfrastructureSystems.Forecast","page":"API","title":"InfrastructureSystems.get_forecast_values","text":"get_forecast_values(_::Type{T<:InfrastructureSystems.Forecast}, mod::Module, component::InfrastructureSystems.InfrastructureSystemsComponent, initial_time::Dates.DateTime, label::AbstractString) -> Any\n\n\nReturn a TimeSeries.TimeArray where the forecast data has been multiplied by the forecasted component field.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.get_forecasts-Union{Tuple{T}, Tuple{T}} where T<:InfrastructureSystems.InfrastructureSystemsComponent","page":"API","title":"InfrastructureSystems.get_forecasts","text":"get_forecasts(value::T<:InfrastructureSystems.InfrastructureSystemsComponent) -> InfrastructureSystems.Forecasts\n\n\nReturn the internal forecast storage container or nothing, if the type doesn't store forecasts.\n\nSubtypes need to implement this method if they store forecasts.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.get_forecasts_horizon-Tuple{InfrastructureSystems.ForecastMetadata}","page":"API","title":"InfrastructureSystems.get_forecasts_horizon","text":"get_forecasts_horizon(forecasts::InfrastructureSystems.ForecastMetadata) -> Int64\n\n\nReturn the horizon for all forecasts.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.get_forecasts_interval-Tuple{InfrastructureSystems.SystemData}","page":"API","title":"InfrastructureSystems.get_forecasts_interval","text":"get_forecasts_interval(data::InfrastructureSystems.SystemData) -> Union{Dates.Millisecond, Dates.Second}\n\n\nReturn the time delta between the first two stored forecasts. if less than two are stored, return Dates.Second(0).\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.get_forecasts_resolution-Tuple{InfrastructureSystems.ForecastMetadata}","page":"API","title":"InfrastructureSystems.get_forecasts_resolution","text":"get_forecasts_resolution(forecasts::InfrastructureSystems.ForecastMetadata) -> Dates.Period\n\n\nReturn the resolution for all forecasts.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.get_horizon-Tuple{InfrastructureSystems.DeterministicInternal}","page":"API","title":"InfrastructureSystems.get_horizon","text":"get_horizon(value::InfrastructureSystems.DeterministicInternal) -> Int64\n\n\nGet DeterministicInternal horizon.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.get_horizon-Tuple{InfrastructureSystems.PiecewiseFunctionInternal}","page":"API","title":"InfrastructureSystems.get_horizon","text":"get_horizon(value::InfrastructureSystems.PiecewiseFunctionInternal) -> Int64\n\n\nGet PiecewiseFunctionInternal horizon.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.get_horizon-Tuple{InfrastructureSystems.ProbabilisticInternal}","page":"API","title":"InfrastructureSystems.get_horizon","text":"get_horizon(value::InfrastructureSystems.ProbabilisticInternal) -> Int64\n\n\nGet ProbabilisticInternal horizon.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.get_horizon-Tuple{InfrastructureSystems.ScenarioBasedInternal}","page":"API","title":"InfrastructureSystems.get_horizon","text":"get_horizon(value::InfrastructureSystems.ScenarioBasedInternal) -> Int64\n\n\nGet ScenarioBasedInternal horizon.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.get_initial_time-Tuple{InfrastructureSystems.DeterministicInternal}","page":"API","title":"InfrastructureSystems.get_initial_time","text":"get_initial_time(value::InfrastructureSystems.DeterministicInternal) -> Dates.DateTime\n\n\nGet DeterministicInternal initial_time.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.get_initial_time-Tuple{InfrastructureSystems.PiecewiseFunctionInternal}","page":"API","title":"InfrastructureSystems.get_initial_time","text":"get_initial_time(value::InfrastructureSystems.PiecewiseFunctionInternal) -> Dates.DateTime\n\n\nGet PiecewiseFunctionInternal initial_time.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.get_initial_time-Tuple{InfrastructureSystems.ProbabilisticInternal}","page":"API","title":"InfrastructureSystems.get_initial_time","text":"get_initial_time(value::InfrastructureSystems.ProbabilisticInternal) -> Dates.DateTime\n\n\nGet ProbabilisticInternal initial_time.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.get_initial_time-Tuple{InfrastructureSystems.ScenarioBasedInternal}","page":"API","title":"InfrastructureSystems.get_initial_time","text":"get_initial_time(value::InfrastructureSystems.ScenarioBasedInternal) -> Dates.DateTime\n\n\nGet ScenarioBasedInternal initial_time.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.get_internal-Tuple{InfrastructureSystems.DeterministicInternal}","page":"API","title":"InfrastructureSystems.get_internal","text":"get_internal(value::InfrastructureSystems.DeterministicInternal) -> InfrastructureSystems.InfrastructureSystemsInternal\n\n\nGet DeterministicInternal internal.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.get_internal-Tuple{InfrastructureSystems.PiecewiseFunctionInternal}","page":"API","title":"InfrastructureSystems.get_internal","text":"get_internal(value::InfrastructureSystems.PiecewiseFunctionInternal) -> InfrastructureSystems.InfrastructureSystemsInternal\n\n\nGet PiecewiseFunctionInternal internal.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.get_internal-Tuple{InfrastructureSystems.ProbabilisticInternal}","page":"API","title":"InfrastructureSystems.get_internal","text":"get_internal(value::InfrastructureSystems.ProbabilisticInternal) -> InfrastructureSystems.InfrastructureSystemsInternal\n\n\nGet ProbabilisticInternal internal.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.get_internal-Tuple{InfrastructureSystems.ScenarioBasedInternal}","page":"API","title":"InfrastructureSystems.get_internal","text":"get_internal(value::InfrastructureSystems.ScenarioBasedInternal) -> InfrastructureSystems.InfrastructureSystemsInternal\n\n\nGet ScenarioBasedInternal internal.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.get_label-Tuple{InfrastructureSystems.DeterministicInternal}","page":"API","title":"InfrastructureSystems.get_label","text":"get_label(value::InfrastructureSystems.DeterministicInternal) -> String\n\n\nGet DeterministicInternal label.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.get_label-Tuple{InfrastructureSystems.Deterministic}","page":"API","title":"InfrastructureSystems.get_label","text":"get_label(value::InfrastructureSystems.Deterministic) -> String\n\n\nGet Deterministic label.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.get_label-Tuple{InfrastructureSystems.PiecewiseFunctionInternal}","page":"API","title":"InfrastructureSystems.get_label","text":"get_label(value::InfrastructureSystems.PiecewiseFunctionInternal) -> String\n\n\nGet PiecewiseFunctionInternal label.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.get_label-Tuple{InfrastructureSystems.PiecewiseFunction}","page":"API","title":"InfrastructureSystems.get_label","text":"get_label(value::InfrastructureSystems.PiecewiseFunction) -> String\n\n\nGet PiecewiseFunction label.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.get_label-Tuple{InfrastructureSystems.ProbabilisticInternal}","page":"API","title":"InfrastructureSystems.get_label","text":"get_label(value::InfrastructureSystems.ProbabilisticInternal) -> String\n\n\nGet ProbabilisticInternal label.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.get_label-Tuple{InfrastructureSystems.Probabilistic}","page":"API","title":"InfrastructureSystems.get_label","text":"get_label(value::InfrastructureSystems.Probabilistic) -> String\n\n\nGet Probabilistic label.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.get_label-Tuple{InfrastructureSystems.ScenarioBasedInternal}","page":"API","title":"InfrastructureSystems.get_label","text":"get_label(value::InfrastructureSystems.ScenarioBasedInternal) -> String\n\n\nGet ScenarioBasedInternal label.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.get_label-Tuple{InfrastructureSystems.ScenarioBased}","page":"API","title":"InfrastructureSystems.get_label","text":"get_label(value::InfrastructureSystems.ScenarioBased) -> String\n\n\nGet ScenarioBased label.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.get_log_events-Tuple{InfrastructureSystems.LogEventTracker,Base.CoreLogging.LogLevel}","page":"API","title":"InfrastructureSystems.get_log_events","text":"get_log_events(tracker::InfrastructureSystems.LogEventTracker, level::Base.CoreLogging.LogLevel) -> Union{Base.ValueIterator{Dict{Symbol,InfrastructureSystems.LogEvent}}, Array{Any,1}}\n\n\nReturns an iterable of log events for a level.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.get_num_steps-Union{Tuple{T}, Tuple{Type{T},CSV.File,AbstractArray}} where T<:InfrastructureSystems.TimeseriesFileFormat","page":"API","title":"InfrastructureSystems.get_num_steps","text":"Return the number of steps specified by the period in the file.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.get_num_steps-Union{Tuple{T}, Tuple{Type{T},CSV.File,AbstractArray}} where T<:InfrastructureSystems.TimeseriesFormatPeriodAsHeader","page":"API","title":"InfrastructureSystems.get_num_steps","text":"get_num_steps(_::Type{T<:InfrastructureSystems.TimeseriesFormatPeriodAsHeader}, file::CSV.File, period::AbstractArray) -> Any\n\n\nReturn the number of steps specified by the period in the file.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.get_num_steps-Union{Tuple{T}, Tuple{Type{T},CSV.File,AbstractArray}} where T<:Union{InfrastructureSystems.TimeseriesFormatDateTimeAsColumn, InfrastructureSystems.TimeseriesFormatPeriodAsColumn}","page":"API","title":"InfrastructureSystems.get_num_steps","text":"get_num_steps(_::Type{T<:Union{InfrastructureSystems.TimeseriesFormatDateTimeAsColumn, InfrastructureSystems.TimeseriesFormatPeriodAsColumn}}, file::CSV.File, period::AbstractArray) -> Any\n\n\nReturn the number of steps specified by the period in the file.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.get_percentiles-Tuple{InfrastructureSystems.ProbabilisticInternal}","page":"API","title":"InfrastructureSystems.get_percentiles","text":"get_percentiles(value::InfrastructureSystems.ProbabilisticInternal) -> Array{Float64,1}\n\n\nGet ProbabilisticInternal percentiles.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.get_percentiles-Tuple{InfrastructureSystems.Probabilistic}","page":"API","title":"InfrastructureSystems.get_percentiles","text":"get_percentiles(value::InfrastructureSystems.Probabilistic) -> Array{Float64,1}\n\n\nGet Probabilistic percentiles.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.get_period_columns-Tuple{Type{InfrastructureSystems.TimeseriesFormatPeriodAsColumn},CSV.File}","page":"API","title":"InfrastructureSystems.get_period_columns","text":"get_period_columns(_::Type{InfrastructureSystems.TimeseriesFormatPeriodAsColumn}, file::CSV.File) -> Array{Symbol,1}\n\n\nReturn the column names that specify the Period.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.get_resolution-Tuple{InfrastructureSystems.DeterministicInternal}","page":"API","title":"InfrastructureSystems.get_resolution","text":"get_resolution(value::InfrastructureSystems.DeterministicInternal) -> Dates.Period\n\n\nGet DeterministicInternal resolution.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.get_resolution-Tuple{InfrastructureSystems.PiecewiseFunctionInternal}","page":"API","title":"InfrastructureSystems.get_resolution","text":"get_resolution(value::InfrastructureSystems.PiecewiseFunctionInternal) -> Dates.Period\n\n\nGet PiecewiseFunctionInternal resolution.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.get_resolution-Tuple{InfrastructureSystems.ProbabilisticInternal}","page":"API","title":"InfrastructureSystems.get_resolution","text":"get_resolution(value::InfrastructureSystems.ProbabilisticInternal) -> Dates.Period\n\n\nGet ProbabilisticInternal resolution.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.get_resolution-Tuple{InfrastructureSystems.ScenarioBasedInternal}","page":"API","title":"InfrastructureSystems.get_resolution","text":"get_resolution(value::InfrastructureSystems.ScenarioBasedInternal) -> Dates.Period\n\n\nGet ScenarioBasedInternal resolution.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.get_scenario_count-Tuple{InfrastructureSystems.ScenarioBasedInternal}","page":"API","title":"InfrastructureSystems.get_scenario_count","text":"get_scenario_count(value::InfrastructureSystems.ScenarioBasedInternal) -> Int64\n\n\nGet ScenarioBasedInternal scenario_count.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.get_scenario_count-Tuple{InfrastructureSystems.ScenarioBased}","page":"API","title":"InfrastructureSystems.get_scenario_count","text":"get_scenario_count(value::InfrastructureSystems.ScenarioBased) -> Int64\n\n\nGet ScenarioBased scenario_count.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.get_step_time-Union{Tuple{T}, Tuple{Type{T},CSV.File,AbstractArray}} where T<:InfrastructureSystems.TimeseriesFileFormat","page":"API","title":"InfrastructureSystems.get_step_time","text":"get_step_time(_::Type{T<:InfrastructureSystems.TimeseriesFileFormat}, file::CSV.File, period::AbstractArray) -> Dates.Second\n\n\nReturn a DateTime for the step between values as specified by the period in the file.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.get_time_series_uuid-Tuple{InfrastructureSystems.DeterministicInternal}","page":"API","title":"InfrastructureSystems.get_time_series_uuid","text":"get_time_series_uuid(value::InfrastructureSystems.DeterministicInternal) -> Base.UUID\n\n\nGet DeterministicInternal time_series_uuid.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.get_time_series_uuid-Tuple{InfrastructureSystems.PiecewiseFunctionInternal}","page":"API","title":"InfrastructureSystems.get_time_series_uuid","text":"get_time_series_uuid(value::InfrastructureSystems.PiecewiseFunctionInternal) -> Base.UUID\n\n\nGet PiecewiseFunctionInternal time_series_uuid.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.get_time_series_uuid-Tuple{InfrastructureSystems.ProbabilisticInternal}","page":"API","title":"InfrastructureSystems.get_time_series_uuid","text":"get_time_series_uuid(value::InfrastructureSystems.ProbabilisticInternal) -> Base.UUID\n\n\nGet ProbabilisticInternal time_series_uuid.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.get_time_series_uuid-Tuple{InfrastructureSystems.ScenarioBasedInternal}","page":"API","title":"InfrastructureSystems.get_time_series_uuid","text":"get_time_series_uuid(value::InfrastructureSystems.ScenarioBasedInternal) -> Base.UUID\n\n\nGet ScenarioBasedInternal time_series_uuid.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.get_timeseries_format-Tuple{CSV.File}","page":"API","title":"InfrastructureSystems.get_timeseries_format","text":"get_timeseries_format(file::CSV.File) -> Type\n\n\nReturn the timeseries format used in the CSV file.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.get_timestamp-Tuple{Type{InfrastructureSystems.TimeseriesFormatYMDPeriodAsColumn},CSV.File,Int64}","page":"API","title":"InfrastructureSystems.get_timestamp","text":"get_timestamp(_::Type{InfrastructureSystems.TimeseriesFormatYMDPeriodAsColumn}, file::CSV.File, row_index::Int64) -> Any\n\n\nReturn a Dates.DateTime for the row in the CSV file.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.get_unique_timestamps-Union{Tuple{T}, Tuple{Type{T},CSV.File}} where T<:InfrastructureSystems.TimeseriesFileFormat","page":"API","title":"InfrastructureSystems.get_unique_timestamps","text":"get_unique_timestamps(_::Type{T<:InfrastructureSystems.TimeseriesFileFormat}, file::CSV.File) -> Array{Dict{String,Any},1}\n\n\nReturn a vector of dicts of unique timestamps and their counts.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.get_uuid-Tuple{InfrastructureSystems.InfrastructureSystemsType}","page":"API","title":"InfrastructureSystems.get_uuid","text":"get_uuid(obj::InfrastructureSystems.InfrastructureSystemsType) -> Base.UUID\n\n\nGets the UUID for any InfrastructureSystemsType.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.get_value_columns-Tuple{Type{InfrastructureSystems.TimeseriesFormatComponentsAsColumnsNoTime},CSV.File}","page":"API","title":"InfrastructureSystems.get_value_columns","text":"get_value_columns(_::Type{InfrastructureSystems.TimeseriesFormatComponentsAsColumnsNoTime}, file::CSV.File) -> Array{Symbol,1}\n\n\nReturn the column names with values.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.get_value_columns-Tuple{Type{InfrastructureSystems.TimeseriesFormatYMDPeriodAsColumn},CSV.File}","page":"API","title":"InfrastructureSystems.get_value_columns","text":"get_value_columns(_::Type{InfrastructureSystems.TimeseriesFormatYMDPeriodAsColumn}, file::CSV.File) -> Array{Symbol,1}\n\n\nReturn the column names with values (components).\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.head-Tuple{InfrastructureSystems.Forecast}","page":"API","title":"InfrastructureSystems.head","text":"head(forecast::InfrastructureSystems.Forecast) -> Any\n\n\nReturn a forecast with only the first num values.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.increment_count-Tuple{InfrastructureSystems.LogEventTracker,InfrastructureSystems.LogEvent,Bool}","page":"API","title":"InfrastructureSystems.increment_count","text":"increment_count(tracker::InfrastructureSystems.LogEventTracker, event::InfrastructureSystems.LogEvent, suppressed::Bool) -> Union{Nothing, Int64, InfrastructureSystems.LogEvent}\n\n\nIncrements the count of a log event.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.iterate_components-Tuple{InfrastructureSystems.Components}","page":"API","title":"InfrastructureSystems.iterate_components","text":"iterate_components(components::InfrastructureSystems.Components) -> Channel{Any}\n\n\nIterates over all components.\n\nExamples\n\nfor component in iterate_components(obj)\n    @show component\nend\n\nSee also: get_components\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.iterate_forecasts","page":"API","title":"InfrastructureSystems.iterate_forecasts","text":"iterate_forecasts(data::InfrastructureSystems.SystemData) -> Channel{Any}\niterate_forecasts(data::InfrastructureSystems.SystemData, filter_func::Any; type, initial_time, label) -> Channel{Any}\n\n\nReturns an iterator of Forecast instances attached to the system.\n\nNote that passing a filter function can be much slower than the other filtering parameters because it reads time series data from media.\n\nCall collect on the result to get an array.\n\nArguments\n\ndata::SystemData: system\nfilter_func = nothing: Only return forecasts for which this returns true.\ntype = nothing: Only return forecasts with this type.\ninitial_time = nothing: Only return forecasts matching this value.\nlabel = nothing: Only return forecasts matching this value.\n\n\n\n\n\n","category":"function"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.iterate_forecasts-2","page":"API","title":"InfrastructureSystems.iterate_forecasts","text":"iterate_forecasts(component::InfrastructureSystems.InfrastructureSystemsComponent) -> Channel{Any}\niterate_forecasts(component::InfrastructureSystems.InfrastructureSystemsComponent, filter_func::Any; type, initial_time, label) -> Channel{Any}\n\n\nReturns an iterator of Forecast instances attached to the component.\n\nNote that passing a filter function can be much slower than the other filtering parameters because it reads time series data from media.\n\nCall collect on the result to get an array.\n\nArguments\n\ncomponent::InfrastructureSystemsComponent: component from which to get forecasts\nfilter_func = nothing: Only return forecasts for which this returns true.\ntype = nothing: Only return forecasts with this type.\ninitial_time = nothing: Only return forecasts matching this value.\nlabel = nothing: Only return forecasts matching this value.\n\n\n\n\n\n","category":"function"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.iterate_forecasts-Tuple{Type{InfrastructureSystems.ForecastInternal},InfrastructureSystems.InfrastructureSystemsComponent}","page":"API","title":"InfrastructureSystems.iterate_forecasts","text":"iterate_forecasts(_::Type{InfrastructureSystems.ForecastInternal}, component::InfrastructureSystems.InfrastructureSystemsComponent) -> Channel{Any}\n\n\nReturns an iterator of ForecastInternal instances attached to the component.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.list_recorder_events-Union{Tuple{T}, Tuple{Type{T},AbstractString}, Tuple{Type{T},AbstractString,Union{Nothing, Function}}} where T<:InfrastructureSystems.AbstractRecorderEvent","page":"API","title":"InfrastructureSystems.list_recorder_events","text":"list_recorder_events(::Type{T<:InfrastructureSystems.AbstractRecorderEvent}, filename::AbstractString) -> Array{_A,1} where _A\nlist_recorder_events(::Type{T<:InfrastructureSystems.AbstractRecorderEvent}, filename::AbstractString, filter_func::Union{Nothing, Function}) -> Array{_A,1} where _A\n\n\nReturn the events of type T in filename.\n\nArguments\n\nT: event type\nfilename::AbstractString: filename containing recorder events\nfilter_func::Union{Nothing, Function} = nothing: Optional function that accepts an event  of type T and returns a Bool. Apply this function to each event and only return events  where the result is true.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.make_forecast!-Tuple{InfrastructureSystems.ForecastCache,InfrastructureSystems.TimeseriesFileMetadata}","page":"API","title":"InfrastructureSystems.make_forecast!","text":"make_forecast!(forecast_cache::InfrastructureSystems.ForecastCache, timeseries_metadata::InfrastructureSystems.TimeseriesFileMetadata; resolution) -> Tuple{Any,InfrastructureSystems.TimeSeriesData}\n\n\nReturn a vector of forecasts from TimeseriesFileMetadata.\n\nArguments\n\ntimeseries_metadata::TimeseriesFileMetadata: metadata\nresolution::{Nothing, Dates.Period}: skip any forecasts that don't match this resolution\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.open_file_logger","page":"API","title":"InfrastructureSystems.open_file_logger","text":"open_file_logger(func::Function, filename::String) -> Any\nopen_file_logger(func::Function, filename::String, level::Any) -> Any\nopen_file_logger(func::Function, filename::String, level::Any, mode::Any) -> Any\n\n\nOpens a file logger using Logging.SimpleLogger.\n\nExample\n\nopen_file_logger(\"log.txt\", Logging.Info) do logger\n    global_logger(logger)\n    @info \"hello world\"\nend\n\n\n\n\n\n","category":"function"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.parse_serialized_type-Tuple{Union{String, Symbol}}","page":"API","title":"InfrastructureSystems.parse_serialized_type","text":"parse_serialized_type(serialized_type::Union{String, Symbol}) -> Union{Expr, Symbol}\n\n\nReturn a symbol parsed from a serialized string. Sanitizes the input first and attempts to ensure that the string does not contain code. The caller can call eval on the returned symbol.\n\nThrows ErrorException if the string contains invalid characters or code.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.prepare_for_removal!-Tuple{InfrastructureSystems.InfrastructureSystemsComponent}","page":"API","title":"InfrastructureSystems.prepare_for_removal!","text":"prepare_for_removal!(component::InfrastructureSystems.InfrastructureSystemsComponent)\n\n\nThis function must be called when a component is removed from a system.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.prepare_for_serialization!-Tuple{InfrastructureSystems.SystemData,AbstractString}","page":"API","title":"InfrastructureSystems.prepare_for_serialization!","text":"prepare_for_serialization!(data::InfrastructureSystems.SystemData, filename::AbstractString; force) -> String\n\n\nParent object should call this prior to serialization so that SystemData can store the appropriate path information for the time series data.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.read_time_series","page":"API","title":"InfrastructureSystems.read_time_series","text":"read_time_series(file_path::AbstractString) -> Union{TimeSeries.TimeArray{_A,_B,Dates.DateTime,_C} where _C<:AbstractArray{_A,_B} where _B, TimeSeries.TimeArray{_A,_B,Dates.DateTime,_C} where _C<:AbstractArray{_A,_B} where _B, TimeSeries.TimeArray{_A,N,Dates.DateTime,_C} where _C<:AbstractArray{_A,N} where N} where _A\nread_time_series(file_path::AbstractString, component_name::Any; kwargs...) -> Union{TimeSeries.TimeArray{_A,_B,Dates.DateTime,_C} where _C<:AbstractArray{_A,_B} where _B, TimeSeries.TimeArray{_A,_B,Dates.DateTime,_C} where _C<:AbstractArray{_A,_B} where _B, TimeSeries.TimeArray{_A,N,Dates.DateTime,_C} where _C<:AbstractArray{_A,N} where N} where _A\n\n\nReturn a TimeArray from a CSV file.\n\nPass component_name when the file does not have the component name in a column header.\n\n\n\n\n\n","category":"function"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.read_time_series-Union{Tuple{T}, Tuple{Type{T},CSV.File,AbstractString}} where T<:InfrastructureSystems.TimeseriesFormatPeriodAsHeader","page":"API","title":"InfrastructureSystems.read_time_series","text":"read_time_series(::Type{T<:InfrastructureSystems.TimeseriesFormatPeriodAsHeader}, file::CSV.File, component_name::AbstractString; kwargs...) -> TimeSeries.TimeArray{Float64,1,Dates.DateTime,Array{Float64,1}}\n\n\nThis version of the function supports the format where there is no column header for a component, so the component_name must be passed in.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.read_time_series-Union{Tuple{T}, Tuple{Type{T},CSV.File}, Tuple{Type{T},CSV.File,Any}} where T<:InfrastructureSystems.TimeseriesFormatComponentsAsColumnsNoTime","page":"API","title":"InfrastructureSystems.read_time_series","text":"read_time_series(::Type{T<:InfrastructureSystems.TimeseriesFormatComponentsAsColumnsNoTime}, file::CSV.File) -> Union{TimeSeries.TimeArray{_A,_B,Dates.DateTime,_C} where _C<:AbstractArray{_A,_B} where _B, TimeSeries.TimeArray{_A,_B,Dates.DateTime,_C} where _C<:AbstractArray{_A,_B} where _B, TimeSeries.TimeArray{_A,N,Dates.DateTime,_C} where _C<:AbstractArray{_A,N} where N} where _A\nread_time_series(::Type{T<:InfrastructureSystems.TimeseriesFormatComponentsAsColumnsNoTime}, file::CSV.File, component_name::Any; kwargs...) -> Union{TimeSeries.TimeArray{_A,_B,Dates.DateTime,_C} where _C<:AbstractArray{_A,_B} where _B, TimeSeries.TimeArray{_A,_B,Dates.DateTime,_C} where _C<:AbstractArray{_A,_B} where _B, TimeSeries.TimeArray{_A,N,Dates.DateTime,_C} where _C<:AbstractArray{_A,N} where N} where _A\n\n\nThis version of the function only has component_name to match the interface. It is unused.\n\nSet start_datetime as a keyword argument for the starting timestamp, otherwise the current day is used.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.read_time_series-Union{Tuple{T}, Tuple{Type{T},CSV.File}, Tuple{Type{T},CSV.File,Any}} where T<:InfrastructureSystems.TimeseriesFormatDateTimeAsColumn","page":"API","title":"InfrastructureSystems.read_time_series","text":"read_time_series(::Type{T<:InfrastructureSystems.TimeseriesFormatDateTimeAsColumn}, file::CSV.File) -> Union{TimeSeries.TimeArray{_A,_B,Dates.DateTime,_C} where _C<:AbstractArray{_A,_B} where _B, TimeSeries.TimeArray{_A,_B,Dates.DateTime,_C} where _C<:AbstractArray{_A,_B} where _B, TimeSeries.TimeArray{_A,N,Dates.DateTime,_C} where _C<:AbstractArray{_A,N} where N} where _A\nread_time_series(::Type{T<:InfrastructureSystems.TimeseriesFormatDateTimeAsColumn}, file::CSV.File, component_name::Any; kwargs...) -> Union{TimeSeries.TimeArray{_A,_B,Dates.DateTime,_C} where _C<:AbstractArray{_A,_B} where _B, TimeSeries.TimeArray{_A,_B,Dates.DateTime,_C} where _C<:AbstractArray{_A,_B} where _B, TimeSeries.TimeArray{_A,N,Dates.DateTime,_C} where _C<:AbstractArray{_A,N} where N} where _A\n\n\nReturn a TimeSeries.TimeArray representing the CSV file.\n\nThis version of the function only has component_name to match the interface. It is unused.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.read_time_series-Union{Tuple{T}, Tuple{Type{T},CSV.File}, Tuple{Type{T},CSV.File,Any}} where T<:InfrastructureSystems.TimeseriesFormatPeriodAsColumn","page":"API","title":"InfrastructureSystems.read_time_series","text":"read_time_series(::Type{T<:InfrastructureSystems.TimeseriesFormatPeriodAsColumn}, file::CSV.File) -> Union{TimeSeries.TimeArray{_A,_B,Dates.DateTime,_C} where _C<:AbstractArray{_A,_B} where _B, TimeSeries.TimeArray{_A,_B,Dates.DateTime,_C} where _C<:AbstractArray{_A,_B} where _B, TimeSeries.TimeArray{_A,N,Dates.DateTime,_C} where _C<:AbstractArray{_A,N} where N} where _A\nread_time_series(::Type{T<:InfrastructureSystems.TimeseriesFormatPeriodAsColumn}, file::CSV.File, component_name::Any; kwargs...) -> Union{TimeSeries.TimeArray{_A,_B,Dates.DateTime,_C} where _C<:AbstractArray{_A,_B} where _B, TimeSeries.TimeArray{_A,_B,Dates.DateTime,_C} where _C<:AbstractArray{_A,_B} where _B, TimeSeries.TimeArray{_A,N,Dates.DateTime,_C} where _C<:AbstractArray{_A,N} where N} where _A\n\n\nReturn a TimeSeries.TimeArray representing the CSV file.\n\nThis version of the function only has component_name to match the interface. It is unused.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.read_time_series_metadata-Tuple{AbstractString}","page":"API","title":"InfrastructureSystems.read_time_series_metadata","text":"read_time_series_metadata(file_path::AbstractString) -> Any\n\n\nReads forecast metadata and fixes relative paths to the data files.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.redirect_stdout_to_log-Tuple{Function}","page":"API","title":"InfrastructureSystems.redirect_stdout_to_log","text":"redirect_stdout_to_log(func::Function) -> Any\n\n\nRedirect all data written to stdout by a function to log events.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.register_recorder!-Tuple{Symbol}","page":"API","title":"InfrastructureSystems.register_recorder!","text":"register_recorder!(name::Symbol; io, mode, directory)\n\n\nRegister a recorder to log events. Afterwards, calls to @record name <event-type>() will record the event as JSON in <name>.log.\n\nCallers should guarantee that unregister_recorder! is called to close the file handle.\n\nArguments\n\nname::Symbol: name of recorder\nio::Union{Nothing, IO}:  If nothing, record events in a file using name.\nmode = \"w\":  Only used when io is nothing.\ndirectory = \".\":  Only used when io is nothing.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.remove_component!-Union{Tuple{T}, Tuple{InfrastructureSystems.Components,T}} where T<:InfrastructureSystems.InfrastructureSystemsComponent","page":"API","title":"InfrastructureSystems.remove_component!","text":"remove_component!(components::InfrastructureSystems.Components, component::T<:InfrastructureSystems.InfrastructureSystemsComponent) -> InfrastructureSystems.InfrastructureSystemsComponent\n\n\nRemove a component by its value.\n\nThrows ArgumentError if the component is not stored.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.remove_component!-Union{Tuple{T}, Tuple{Type{T},InfrastructureSystems.Components,AbstractString}} where T<:InfrastructureSystems.InfrastructureSystemsComponent","page":"API","title":"InfrastructureSystems.remove_component!","text":"remove_component!(_::Type{T<:InfrastructureSystems.InfrastructureSystemsComponent}, components::InfrastructureSystems.Components, name::AbstractString) -> InfrastructureSystems.InfrastructureSystemsComponent\n\n\nRemove a component by its name.\n\nThrows ArgumentError if the component is not stored.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.remove_components!-Union{Tuple{T}, Tuple{Type{T},InfrastructureSystems.Components}} where T<:InfrastructureSystems.InfrastructureSystemsComponent","page":"API","title":"InfrastructureSystems.remove_components!","text":"remove_components!(_::Type{T<:InfrastructureSystems.InfrastructureSystemsComponent}, components::InfrastructureSystems.Components) -> Base.ValueIterator\n\n\nRemove all components of type T.\n\nThrows ArgumentError if the type is not stored.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.remove_forecast!-Union{Tuple{T}, Tuple{Type{T},InfrastructureSystems.SystemData,InfrastructureSystems.InfrastructureSystemsComponent,Dates.DateTime,String}} where T<:InfrastructureSystems.Forecast","page":"API","title":"InfrastructureSystems.remove_forecast!","text":"remove_forecast!(_::Type{T<:InfrastructureSystems.Forecast}, data::InfrastructureSystems.SystemData, component::InfrastructureSystems.InfrastructureSystemsComponent, initial_time::Dates.DateTime, label::String) -> Union{Nothing, Int32, InfrastructureSystems._TimeSeriesRecord}\n\n\nRemove the time series data for a component.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.remove_forecast_internal!-Union{Tuple{T}, Tuple{Type{T},InfrastructureSystems.InfrastructureSystemsComponent,Dates.DateTime,AbstractString}} where T<:InfrastructureSystems.ForecastInternal","page":"API","title":"InfrastructureSystems.remove_forecast_internal!","text":"remove_forecast_internal!(_::Type{T<:InfrastructureSystems.ForecastInternal}, component::InfrastructureSystems.InfrastructureSystemsComponent, initial_time::Dates.DateTime, label::AbstractString)\n\n\nRemoves the metadata for a forecast. The caller must also remove the actual time series data.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.replace_iterator-Tuple{InfrastructureSystems.LazyDictFromIterator,Any}","page":"API","title":"InfrastructureSystems.replace_iterator","text":"replace_iterator(container::InfrastructureSystems.LazyDictFromIterator, iter::Any) -> Any\n\n\nReplace the iterator, maintaining the cached dict.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.report_log_summary-Tuple{InfrastructureSystems.LogEventTracker}","page":"API","title":"InfrastructureSystems.report_log_summary","text":"report_log_summary(tracker::InfrastructureSystems.LogEventTracker) -> String\n\n\nReturns a summary of log event counts by level.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.report_log_summary-Tuple{InfrastructureSystems.MultiLogger}","page":"API","title":"InfrastructureSystems.report_log_summary","text":"report_log_summary(logger::InfrastructureSystems.MultiLogger) -> String\n\n\nReturns a summary of log event counts by level.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.reset_iterator-Tuple{InfrastructureSystems.LazyDictFromIterator}","page":"API","title":"InfrastructureSystems.reset_iterator","text":"reset_iterator(container::InfrastructureSystems.LazyDictFromIterator)\n\n\nReset the iterator for cases where underlying arrays have changed.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.serialize-Union{Tuple{T}, Tuple{T}} where T<:InfrastructureSystems.InfrastructureSystemsType","page":"API","title":"InfrastructureSystems.serialize","text":"Serialize the Julia value into standard types that can be converted to non-Julia formats, such as JSON. In cases where val is an instance of a struct, return a Dict. In cases where val is a scalar value, return that value.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.set_break_points!-Tuple{InfrastructureSystems.PiecewiseFunction,Any}","page":"API","title":"InfrastructureSystems.set_break_points!","text":"set_break_points!(value::InfrastructureSystems.PiecewiseFunction, val::Any) -> Any\n\n\nSet PiecewiseFunction break_points.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.set_break_points!-Tuple{InfrastructureSystems.PiecewiseFunctionInternal,Any}","page":"API","title":"InfrastructureSystems.set_break_points!","text":"set_break_points!(value::InfrastructureSystems.PiecewiseFunctionInternal, val::Any) -> Any\n\n\nSet PiecewiseFunctionInternal break_points.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.set_component!-Tuple{InfrastructureSystems.TimeseriesFileMetadata,InfrastructureSystems.SystemData,Module}","page":"API","title":"InfrastructureSystems.set_component!","text":"set_component!(metadata::InfrastructureSystems.TimeseriesFileMetadata, data::InfrastructureSystems.SystemData, mod::Module) -> Any\n\n\nSet the component value in metadata by looking up the category in module. This requires that category be a string version of a component's abstract type. Modules can override for custom behavior.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.set_data!-Tuple{InfrastructureSystems.Deterministic,Any}","page":"API","title":"InfrastructureSystems.set_data!","text":"set_data!(value::InfrastructureSystems.Deterministic, val::Any) -> Any\n\n\nSet Deterministic data.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.set_data!-Tuple{InfrastructureSystems.PiecewiseFunction,Any}","page":"API","title":"InfrastructureSystems.set_data!","text":"set_data!(value::InfrastructureSystems.PiecewiseFunction, val::Any) -> Any\n\n\nSet PiecewiseFunction data.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.set_data!-Tuple{InfrastructureSystems.Probabilistic,Any}","page":"API","title":"InfrastructureSystems.set_data!","text":"set_data!(value::InfrastructureSystems.Probabilistic, val::Any) -> Any\n\n\nSet Probabilistic data.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.set_data!-Tuple{InfrastructureSystems.ScenarioBased,Any}","page":"API","title":"InfrastructureSystems.set_data!","text":"set_data!(value::InfrastructureSystems.ScenarioBased, val::Any) -> Any\n\n\nSet ScenarioBased data.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.set_horizon!-Tuple{InfrastructureSystems.DeterministicInternal,Any}","page":"API","title":"InfrastructureSystems.set_horizon!","text":"set_horizon!(value::InfrastructureSystems.DeterministicInternal, val::Any) -> Any\n\n\nSet DeterministicInternal horizon.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.set_horizon!-Tuple{InfrastructureSystems.PiecewiseFunctionInternal,Any}","page":"API","title":"InfrastructureSystems.set_horizon!","text":"set_horizon!(value::InfrastructureSystems.PiecewiseFunctionInternal, val::Any) -> Any\n\n\nSet PiecewiseFunctionInternal horizon.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.set_horizon!-Tuple{InfrastructureSystems.ProbabilisticInternal,Any}","page":"API","title":"InfrastructureSystems.set_horizon!","text":"set_horizon!(value::InfrastructureSystems.ProbabilisticInternal, val::Any) -> Any\n\n\nSet ProbabilisticInternal horizon.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.set_horizon!-Tuple{InfrastructureSystems.ScenarioBasedInternal,Any}","page":"API","title":"InfrastructureSystems.set_horizon!","text":"set_horizon!(value::InfrastructureSystems.ScenarioBasedInternal, val::Any) -> Any\n\n\nSet ScenarioBasedInternal horizon.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.set_initial_time!-Tuple{InfrastructureSystems.DeterministicInternal,Any}","page":"API","title":"InfrastructureSystems.set_initial_time!","text":"set_initial_time!(value::InfrastructureSystems.DeterministicInternal, val::Any) -> Any\n\n\nSet DeterministicInternal initial_time.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.set_initial_time!-Tuple{InfrastructureSystems.PiecewiseFunctionInternal,Any}","page":"API","title":"InfrastructureSystems.set_initial_time!","text":"set_initial_time!(value::InfrastructureSystems.PiecewiseFunctionInternal, val::Any) -> Any\n\n\nSet PiecewiseFunctionInternal initial_time.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.set_initial_time!-Tuple{InfrastructureSystems.ProbabilisticInternal,Any}","page":"API","title":"InfrastructureSystems.set_initial_time!","text":"set_initial_time!(value::InfrastructureSystems.ProbabilisticInternal, val::Any) -> Any\n\n\nSet ProbabilisticInternal initial_time.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.set_initial_time!-Tuple{InfrastructureSystems.ScenarioBasedInternal,Any}","page":"API","title":"InfrastructureSystems.set_initial_time!","text":"set_initial_time!(value::InfrastructureSystems.ScenarioBasedInternal, val::Any) -> Any\n\n\nSet ScenarioBasedInternal initial_time.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.set_internal!-Tuple{InfrastructureSystems.DeterministicInternal,Any}","page":"API","title":"InfrastructureSystems.set_internal!","text":"set_internal!(value::InfrastructureSystems.DeterministicInternal, val::Any) -> Any\n\n\nSet DeterministicInternal internal.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.set_internal!-Tuple{InfrastructureSystems.PiecewiseFunctionInternal,Any}","page":"API","title":"InfrastructureSystems.set_internal!","text":"set_internal!(value::InfrastructureSystems.PiecewiseFunctionInternal, val::Any) -> Any\n\n\nSet PiecewiseFunctionInternal internal.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.set_internal!-Tuple{InfrastructureSystems.ProbabilisticInternal,Any}","page":"API","title":"InfrastructureSystems.set_internal!","text":"set_internal!(value::InfrastructureSystems.ProbabilisticInternal, val::Any) -> Any\n\n\nSet ProbabilisticInternal internal.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.set_internal!-Tuple{InfrastructureSystems.ScenarioBasedInternal,Any}","page":"API","title":"InfrastructureSystems.set_internal!","text":"set_internal!(value::InfrastructureSystems.ScenarioBasedInternal, val::Any) -> Any\n\n\nSet ScenarioBasedInternal internal.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.set_label!-Tuple{InfrastructureSystems.Deterministic,Any}","page":"API","title":"InfrastructureSystems.set_label!","text":"set_label!(value::InfrastructureSystems.Deterministic, val::Any) -> Any\n\n\nSet Deterministic label.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.set_label!-Tuple{InfrastructureSystems.DeterministicInternal,Any}","page":"API","title":"InfrastructureSystems.set_label!","text":"set_label!(value::InfrastructureSystems.DeterministicInternal, val::Any) -> Any\n\n\nSet DeterministicInternal label.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.set_label!-Tuple{InfrastructureSystems.PiecewiseFunction,Any}","page":"API","title":"InfrastructureSystems.set_label!","text":"set_label!(value::InfrastructureSystems.PiecewiseFunction, val::Any) -> Any\n\n\nSet PiecewiseFunction label.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.set_label!-Tuple{InfrastructureSystems.PiecewiseFunctionInternal,Any}","page":"API","title":"InfrastructureSystems.set_label!","text":"set_label!(value::InfrastructureSystems.PiecewiseFunctionInternal, val::Any) -> Any\n\n\nSet PiecewiseFunctionInternal label.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.set_label!-Tuple{InfrastructureSystems.Probabilistic,Any}","page":"API","title":"InfrastructureSystems.set_label!","text":"set_label!(value::InfrastructureSystems.Probabilistic, val::Any) -> Any\n\n\nSet Probabilistic label.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.set_label!-Tuple{InfrastructureSystems.ProbabilisticInternal,Any}","page":"API","title":"InfrastructureSystems.set_label!","text":"set_label!(value::InfrastructureSystems.ProbabilisticInternal, val::Any) -> Any\n\n\nSet ProbabilisticInternal label.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.set_label!-Tuple{InfrastructureSystems.ScenarioBased,Any}","page":"API","title":"InfrastructureSystems.set_label!","text":"set_label!(value::InfrastructureSystems.ScenarioBased, val::Any) -> Any\n\n\nSet ScenarioBased label.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.set_label!-Tuple{InfrastructureSystems.ScenarioBasedInternal,Any}","page":"API","title":"InfrastructureSystems.set_label!","text":"set_label!(value::InfrastructureSystems.ScenarioBasedInternal, val::Any) -> Any\n\n\nSet ScenarioBasedInternal label.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.set_percentiles!-Tuple{InfrastructureSystems.Probabilistic,Any}","page":"API","title":"InfrastructureSystems.set_percentiles!","text":"set_percentiles!(value::InfrastructureSystems.Probabilistic, val::Any) -> Any\n\n\nSet Probabilistic percentiles.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.set_percentiles!-Tuple{InfrastructureSystems.ProbabilisticInternal,Any}","page":"API","title":"InfrastructureSystems.set_percentiles!","text":"set_percentiles!(value::InfrastructureSystems.ProbabilisticInternal, val::Any) -> Any\n\n\nSet ProbabilisticInternal percentiles.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.set_resolution!-Tuple{InfrastructureSystems.DeterministicInternal,Any}","page":"API","title":"InfrastructureSystems.set_resolution!","text":"set_resolution!(value::InfrastructureSystems.DeterministicInternal, val::Any) -> Any\n\n\nSet DeterministicInternal resolution.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.set_resolution!-Tuple{InfrastructureSystems.PiecewiseFunctionInternal,Any}","page":"API","title":"InfrastructureSystems.set_resolution!","text":"set_resolution!(value::InfrastructureSystems.PiecewiseFunctionInternal, val::Any) -> Any\n\n\nSet PiecewiseFunctionInternal resolution.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.set_resolution!-Tuple{InfrastructureSystems.ProbabilisticInternal,Any}","page":"API","title":"InfrastructureSystems.set_resolution!","text":"set_resolution!(value::InfrastructureSystems.ProbabilisticInternal, val::Any) -> Any\n\n\nSet ProbabilisticInternal resolution.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.set_resolution!-Tuple{InfrastructureSystems.ScenarioBasedInternal,Any}","page":"API","title":"InfrastructureSystems.set_resolution!","text":"set_resolution!(value::InfrastructureSystems.ScenarioBasedInternal, val::Any) -> Any\n\n\nSet ScenarioBasedInternal resolution.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.set_scenario_count!-Tuple{InfrastructureSystems.ScenarioBased,Any}","page":"API","title":"InfrastructureSystems.set_scenario_count!","text":"set_scenario_count!(value::InfrastructureSystems.ScenarioBased, val::Any) -> Any\n\n\nSet ScenarioBased scenario_count.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.set_scenario_count!-Tuple{InfrastructureSystems.ScenarioBasedInternal,Any}","page":"API","title":"InfrastructureSystems.set_scenario_count!","text":"set_scenario_count!(value::InfrastructureSystems.ScenarioBasedInternal, val::Any) -> Any\n\n\nSet ScenarioBasedInternal scenario_count.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.set_time_series_uuid!-Tuple{InfrastructureSystems.DeterministicInternal,Any}","page":"API","title":"InfrastructureSystems.set_time_series_uuid!","text":"set_time_series_uuid!(value::InfrastructureSystems.DeterministicInternal, val::Any) -> Any\n\n\nSet DeterministicInternal time_series_uuid.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.set_time_series_uuid!-Tuple{InfrastructureSystems.PiecewiseFunctionInternal,Any}","page":"API","title":"InfrastructureSystems.set_time_series_uuid!","text":"set_time_series_uuid!(value::InfrastructureSystems.PiecewiseFunctionInternal, val::Any) -> Any\n\n\nSet PiecewiseFunctionInternal time_series_uuid.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.set_time_series_uuid!-Tuple{InfrastructureSystems.ProbabilisticInternal,Any}","page":"API","title":"InfrastructureSystems.set_time_series_uuid!","text":"set_time_series_uuid!(value::InfrastructureSystems.ProbabilisticInternal, val::Any) -> Any\n\n\nSet ProbabilisticInternal time_series_uuid.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.set_time_series_uuid!-Tuple{InfrastructureSystems.ScenarioBasedInternal,Any}","page":"API","title":"InfrastructureSystems.set_time_series_uuid!","text":"set_time_series_uuid!(value::InfrastructureSystems.ScenarioBasedInternal, val::Any) -> Any\n\n\nSet ScenarioBasedInternal time_series_uuid.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.show_recorder_events-Union{Tuple{T}, Tuple{Type{T},AbstractString}, Tuple{Type{T},AbstractString,Union{Nothing, Function}}} where T<:InfrastructureSystems.AbstractRecorderEvent","page":"API","title":"InfrastructureSystems.show_recorder_events","text":"Show the events of type T in filename in a table. Refer to PrettyTables.jl documentation for accepted kwargs.\n\nArguments\n\nT: event type\nfilename::AbstractString: filename containing recorder events\nfilter_func::Union{Nothing, Function} = nothing: Optional function that accepts an event  of type T and returns a Bool. Apply this function to each event and only return events  where the result is true.\nkwargs: Passed to PrettyTables\n\nExamples\n\nshow_recorder_events(TestEvent, test_recorder.log)\nshow_recorder_events(TestEvent, test_recorder.log; x -> x.val2 > 2)\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.strip_module_name-Tuple{String}","page":"API","title":"InfrastructureSystems.strip_module_name","text":"strip_module_name(name::String) -> String\n\n\nStrips the module name off of a type.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.supertypes-Union{Tuple{Type{T}}, Tuple{T}, Tuple{Type{T},Any}} where T","page":"API","title":"InfrastructureSystems.supertypes","text":"supertypes(::Type{T}) -> Array{Any,1}\nsupertypes(::Type{T}, types::Any) -> Any\n\n\nReturns an array of all super types of T.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.tail-Tuple{InfrastructureSystems.Forecast}","page":"API","title":"InfrastructureSystems.tail","text":"tail(forecast::InfrastructureSystems.Forecast) -> Any\n\n\nReturn a forecast with only the ending num values.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.test_generated_structs-Tuple{Any,Any}","page":"API","title":"InfrastructureSystems.test_generated_structs","text":"test_generated_structs(descriptor_file::Any, existing_dir::Any) -> Bool\n\n\nReturn true if the structs defined in existingdir match structs freshly-generated from descriptorfile.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.to-Union{Tuple{T}, Tuple{T,Any}} where T<:InfrastructureSystems.Forecast","page":"API","title":"InfrastructureSystems.to","text":"Return a forecast truncated after timestamp.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.to_json-Union{Tuple{T}, Tuple{T,AbstractString}} where T<:InfrastructureSystems.InfrastructureSystemsType","page":"API","title":"InfrastructureSystems.to_json","text":"to_json(obj::T<:InfrastructureSystems.InfrastructureSystemsType) -> String\n\n\nSerializes a InfrastructureSystemsType to a JSON file.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.to_json-Union{Tuple{T}, Tuple{T}} where T<:InfrastructureSystems.InfrastructureSystemsType","page":"API","title":"InfrastructureSystems.to_json","text":"Serializes a InfrastructureSystemsType to a JSON string.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.type_to_symbol-Tuple{DataType}","page":"API","title":"InfrastructureSystems.type_to_symbol","text":"type_to_symbol(data_type::DataType) -> Symbol\n\n\nConverts a DataType to a Symbol, stripping off the module name(s).\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.unregister_recorder!-Tuple{Symbol}","page":"API","title":"InfrastructureSystems.unregister_recorder!","text":"unregister_recorder!(name::Symbol; close_io) -> Any\n\n\nUnregister the recorder with this name and stop recording events.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.validate_components-Tuple{InfrastructureSystems.Components}","page":"API","title":"InfrastructureSystems.validate_components","text":"validate_components(components::InfrastructureSystems.Components)\n\n\nIterates over all components and throws InvalidRange if any of the component's field values are outside of defined valid range.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.validate_exported_names-Tuple{Module}","page":"API","title":"InfrastructureSystems.validate_exported_names","text":"validate_exported_names(mod::Module) -> Bool\n\n\nReturn true if all publicly exported names in mod are defined.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.validate_struct-Tuple{InfrastructureSystems.InfrastructureSystemsType}","page":"API","title":"InfrastructureSystems.validate_struct","text":"validate_struct(ist::InfrastructureSystems.InfrastructureSystemsType) -> Bool\n\n\nValidates a struct.\n\n\n\n\n\n","category":"method"},{"location":"api/InfrastructureSystems/#InfrastructureSystems.when-Tuple{InfrastructureSystems.Forecast,Function,Integer}","page":"API","title":"InfrastructureSystems.when","text":"when(forecast::InfrastructureSystems.Forecast, period::Function, t::Integer) -> Any\n\n\nRefer to TimeSeries.when(). Underlying data is copied.\n\n\n\n\n\n","category":"method"},{"location":"user_guide/guide/#User-Guide","page":"User Guide","title":"User Guide","text":"","category":"section"},{"location":"user_guide/guide/#Component-structs","page":"User Guide","title":"Component structs","text":"","category":"section"},{"location":"user_guide/guide/","page":"User Guide","title":"User Guide","text":"InfrastructureSystems provides a common way of managing component structs in a system.","category":"page"},{"location":"user_guide/guide/#Type-hierachy","page":"User Guide","title":"Type hierachy","text":"","category":"section"},{"location":"user_guide/guide/","page":"User Guide","title":"User Guide","text":"Make every component a subtype of InfrastructureSystemsComponent.","category":"page"},{"location":"user_guide/guide/#Interface-requirements","page":"User Guide","title":"Interface requirements","text":"","category":"section"},{"location":"user_guide/guide/","page":"User Guide","title":"User Guide","text":"Implement a get_name(c::MyComponent)::String method for every struct.","category":"page"},{"location":"user_guide/guide/#InfrastructureSystemsInternal","page":"User Guide","title":"InfrastructureSystemsInternal","text":"","category":"section"},{"location":"user_guide/guide/","page":"User Guide","title":"User Guide","text":"Add this struct to every component struct.","category":"page"},{"location":"user_guide/guide/","page":"User Guide","title":"User Guide","text":"It automatically creates a UUID for the component. This guarantees a unique way to identify the component.\nIt optionally provides an extension dictionary for user data. A user extending your package may want to use your struct but need one more field. Rather than create a new type they can add data to this ext object.","category":"page"},{"location":"user_guide/guide/#Instructions","page":"User Guide","title":"Instructions","text":"","category":"section"},{"location":"user_guide/guide/","page":"User Guide","title":"User Guide","text":"Add the field to your struct. The constructor does not take any parameters.","category":"page"},{"location":"user_guide/guide/","page":"User Guide","title":"User Guide","text":"struct MyComponent\n    internal::InfrastructureSystemsInternal\nend\n\n# Optional\nget_ext(c::MyComponent) = InfrastructureSystems.get_ext(c.ext)\nclear_ext!(c::MyComponent) = InfrastructureSystems.clear_ext(c.ext)","category":"page"},{"location":"user_guide/guide/","page":"User Guide","title":"User Guide","text":"Notes:","category":"page"},{"location":"user_guide/guide/","page":"User Guide","title":"User Guide","text":"InfrastructureSystems.get_uuid(obj::InfrastructureSystemsComponent) returns the component UUID.\nThe extension dictionary is not created until the first time get_ext is called.","category":"page"},{"location":"user_guide/guide/#Auto-Generation-of-component-structs","page":"User Guide","title":"Auto-Generation of component structs","text":"","category":"section"},{"location":"user_guide/guide/","page":"User Guide","title":"User Guide","text":"InfrastructureSystems provides a mechanism to auto-generate Julia files containing structs and field accessor functions from JSON descriptors. Here are reasons to consider using this approach:","category":"page"},{"location":"user_guide/guide/","page":"User Guide","title":"User Guide","text":"Auto-generation allows for easy refactoring of code. Adding fields to many structs can be tedious because you might have to edit many constructors. This process eliminates boiler-plate edits.\nThe JSON descriptor format includes a mechanisim to define range validation on component fields. Validation can be enabled when adding components to a system.\nProvides consistent formatting of structs, fields, and constructors.\nProvides consistent documentation of structs and fields.","category":"page"},{"location":"user_guide/guide/#Instructions-2","page":"User Guide","title":"Instructions","text":"","category":"section"},{"location":"user_guide/guide/","page":"User Guide","title":"User Guide","text":"Create the JSON descriptor file. Follow the PowerSystems.jl example.\nRun the generation script, passing your descriptor file and an output directory.","category":"page"},{"location":"user_guide/guide/","page":"User Guide","title":"User Guide","text":"InfrastructureSystems.generate_structs(\"./src/descriptors/power_system_structs.json\", \"./src/models/generated\")","category":"page"},{"location":"user_guide/guide/","page":"User Guide","title":"User Guide","text":"Notes:","category":"page"},{"location":"user_guide/guide/","page":"User Guide","title":"User Guide","text":"The code generation template provides several options which are not yet formally documented. Browse the PowerSystems example or the generation script.\nYou will need to decide how to manage the generated files. The PowerSystems package keeps the generated code in the git repository. This is not required. You could choose to generate them at startup.\nYou may need to create custom constructors and this approach will not allow you have put them in the same file as the struct definition.","category":"page"},{"location":"user_guide/guide/#Component-time-series-data","page":"User Guide","title":"Component time series data","text":"","category":"section"},{"location":"user_guide/guide/","page":"User Guide","title":"User Guide","text":"InfrastructureSystems provides a mechanism to store time series data for components. Here are reasons to consider using it:","category":"page"},{"location":"user_guide/guide/","page":"User Guide","title":"User Guide","text":"Time series data, by default, is stored independently of components in HDF5 files. Components store references to that data.\nSystem memory is not depleted by loading all time series data at once. Only data that you need is loaded.\nMultiple components can share the same time series data by sharing references instead of making expensive copies.\nSupports serialization and deserialization.\nSupports parsing raw data files of several formats as well as data stored in TimeSeries.TimeArray and DataFrames.DataFrame objects.","category":"page"},{"location":"user_guide/guide/","page":"User Guide","title":"User Guide","text":":warning: You must reimplement deepcopy if you use HDF5","category":"page"},{"location":"user_guide/guide/","page":"User Guide","title":"User Guide","text":"If you store an instance of SystemData within your system and then a user calls deepcopy on a system, the .h5 file will not be copied. The new and old instances will have references to the same file. You will need to reimplement deepcopy to handle this. One solution is to serialize and then deserialize the system.","category":"page"},{"location":"user_guide/guide/","page":"User Guide","title":"User Guide","text":"Notes:","category":"page"},{"location":"user_guide/guide/","page":"User Guide","title":"User Guide","text":"Time series data can optionally be stored fully in memory. Refer to the","category":"page"},{"location":"user_guide/guide/","page":"User Guide","title":"User Guide","text":"SystemData documentation.","category":"page"},{"location":"user_guide/guide/","page":"User Guide","title":"User Guide","text":"InfrastructureSystems creates HDF5 files on the tmp filesystem by default. This can be changed if the time series data is larger than the amount of tmp space available. Refer to the SystemData link above.","category":"page"},{"location":"user_guide/guide/#Instructions-3","page":"User Guide","title":"Instructions","text":"","category":"section"},{"location":"user_guide/guide/","page":"User Guide","title":"User Guide","text":"Add an instance of InfrastructureSystems.Forecasts to the component struct.\nImplement the method InfrastructureSystems.get_forecasts for the component. It must return the Forecasts object.","category":"page"},{"location":"user_guide/guide/#Component-container","page":"User Guide","title":"Component container","text":"","category":"section"},{"location":"user_guide/guide/","page":"User Guide","title":"User Guide","text":"InfrastructureSystems provides the SystemData struct to store a collection of components.","category":"page"},{"location":"user_guide/guide/","page":"User Guide","title":"User Guide","text":"It is recommended but not required that you include this struct within your own   system struct for these reasons:","category":"page"},{"location":"user_guide/guide/","page":"User Guide","title":"User Guide","text":"Provides search and iteration with get_component and get_components for abstract and concrete types.\nEnforces name uniqueness within a concrete type.\nAllows for component field validation.\nEnables component JSON serialization and deserialization.","category":"page"},{"location":"user_guide/guide/#Instructions-4","page":"User Guide","title":"Instructions","text":"","category":"section"},{"location":"user_guide/guide/","page":"User Guide","title":"User Guide","text":"Add an instance of SystemData to your system struct.\nOptionally pass a component validation descriptor file to the constructor.\nOptionally pass time_series_in_memory = true to the constructor if you know that all time series data will fit in memory and want a performance boost.\nRedirect these function calls to your instance of SystemData.\nadd_component!\nremove_component!\nget_component\nget_components\nget_components_by_name\nadd_forecasts!\nadd_forecast!\nremove_forecast!","category":"page"},{"location":"user_guide/guide/#Logging","page":"User Guide","title":"Logging","text":"","category":"section"},{"location":"user_guide/guide/","page":"User Guide","title":"User Guide","text":"InfrastructureSystems provides a MultiLogger object that allows customized logging to console and file. Refer to the logging documentation.","category":"page"},{"location":"user_guide/guide/","page":"User Guide","title":"User Guide","text":"If you want to create a package-specific log file during a simulation, consider the workflow used by PowerSimulations.jl. It creates a custom logger in its build!(Simulation) function and then uses Julia's Logging.with_logger function to temporarily take over the global logger during build() and execute().","category":"page"},{"location":"user_guide/guide/#Recorder-events","page":"User Guide","title":"Recorder events","text":"","category":"section"},{"location":"user_guide/guide/","page":"User Guide","title":"User Guide","text":"InfrastructureSystems provides a mechanism to store structured data in events that get recorded in one or more files. They can be filtered and displayed in tabular form.","category":"page"},{"location":"user_guide/guide/","page":"User Guide","title":"User Guide","text":"The primary use is to store information that can help debug problems.  For example, you may want to store all state transitions in a simulation or every update of a variable.  If a problem occurs you can then display filtered tables of that data to figure out what went wrong.","category":"page"},{"location":"user_guide/guide/#Instructions-5","page":"User Guide","title":"Instructions","text":"","category":"section"},{"location":"user_guide/guide/","page":"User Guide","title":"User Guide","text":"Create events that are subtypes of InfrastructureSystems.AbstractRecorderEvent. Include an instance of RecorderEventCommon in each struct.\nCall InfrastructureSystems.register_recorder(<recorder-name>) for each recorder object you want to create.\nDepending on how often your code create events you may want to make this conditional. You may only need it for debug runs.\nPowerSimulations creates one recorder for simulation step and stage start/stop events that is always enabled. It creates another that is optional but used for frequently-generated events.\nCall @InfrastructureSystems.record <recorder-name> <event> wherever you want to generate events in your code. The event will only get constructed if the recorder is registered.\nCall InfrastructureSystems.unregister_recorder(<recorder-name>) for each registered recorder. You should guarantee this this gets called, even if an exception is thrown.  Otherwise, the file may not get flushed and closed.\nAfter your code runs call InfrastructureSystems.show_recorder_events to view events.  Refer to the docstrings for more information.\nRefer to PowerSimulations.showsimulationevents for an example on how to customize this behavior for your package.","category":"page"},{"location":"#InfrastructureSystems.jl","page":"Welcome Page","title":"InfrastructureSystems.jl","text":"","category":"section"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"CurrentModule = InfrastructureSystems","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"The Documentation is still under construction, some sections are unfinished. The available methods have autogenerated documentation in the internal API section","category":"page"},{"location":"#Overview","page":"Welcome Page","title":"Overview","text":"","category":"section"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"InfrastructureSystems.jl is a Julia package that utilities for the packages in NREL's SIIP Initiative. This package is meant for package development. It is used primarily by PowerSystems.jl and PowerSimulations.jl but is written to be extensible for other kinds of applications as well within.","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"This document describes how to integrate it with other packages.","category":"page"},{"location":"docs/#Documentation","page":"Documentation","title":"Documentation","text":"","category":"section"},{"location":"docs/#Requirements","page":"Documentation","title":"Requirements","text":"","category":"section"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"Pkg.add(\"Documenter\")","category":"page"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"pip install ghp-import","category":"page"},{"location":"docs/#Run","page":"Documentation","title":"Run","text":"","category":"section"},{"location":"docs/","page":"Documentation","title":"Documentation","text":"cd docs\nmake html\nopen build/index.html","category":"page"},{"location":"user_guide/tests/#Running-Tests","page":"Running Tests","title":"Running Tests","text":"","category":"section"},{"location":"user_guide/tests/","page":"Running Tests","title":"Running Tests","text":"Unit tests can be executed in the REPL by executing the following:","category":"page"},{"location":"user_guide/tests/","page":"Running Tests","title":"Running Tests","text":"julia> include(\"test/runtests.jl\")","category":"page"},{"location":"user_guide/tests/","page":"Running Tests","title":"Running Tests","text":"The unit test module supports several customizations to aid development and debug.","category":"page"},{"location":"user_guide/tests/","page":"Running Tests","title":"Running Tests","text":"Run a subset of tests in the REPL:","category":"page"},{"location":"user_guide/tests/","page":"Running Tests","title":"Running Tests","text":"julia> push!(ARGS, \"<test_filename_without_.jl>\")\njulia> include(\"test/runtests.jl\")","category":"page"},{"location":"user_guide/tests/","page":"Running Tests","title":"Running Tests","text":"Change console logging level (defaults to Error):","category":"page"},{"location":"user_guide/tests/","page":"Running Tests","title":"Running Tests","text":"julia> ENV[\"PS_CONSOLE_LOG_LEVEL\"] = Info\njulia> include(\"test/runtests.jl\")","category":"page"},{"location":"user_guide/tests/","page":"Running Tests","title":"Running Tests","text":"Change log file (./power-systems.log) logging level (defaults to Info):","category":"page"},{"location":"user_guide/tests/","page":"Running Tests","title":"Running Tests","text":"julia> ENV[\"PS_LOG_LEVEL\"] = Debug\njulia> include(\"test/runtests.jl\")","category":"page"},{"location":"user_guide/tests/","page":"Running Tests","title":"Running Tests","text":"The unit test module appends a summary of all log message counts to the log file.  If a message is logged too frequently then consider tagging that message with maxlog=X to suppress it.","category":"page"}]
}
